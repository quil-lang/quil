@section[:title "Introduction"]

@p{This is the language specification for Quil, a language for hybrid
classical/quantum computations.}

@p{Quil is an instruction-based language; each line of a Quil program
generally corresponds to a single, discrete action. Despite its
resemblance, Quil is @emph{not} an assembly language.}

@aside{An @emph{assembly language} is a textual format for the machine
code of a specific computer architecture. Quil is not that, and may be
used for a variety of quantum computer architectures.}

@p{This is an example Quil program that simulates a coin flip:

@clist{
DECLARE ro BIT[1]
H 0
MEASURE 0 ro[0]
}

Here, we can see the use of both classical data and quantum data. The
qubit numbered @c{0} is prepared in a uniform superposition by the
Hadamard gate @c{H}, and then measured in the computational basis,
depositing the resulting bit into a classic bit register named @c{ro}.
}

@p{The remainder of this document serves as a reference for all Quil
language syntax constructs and their associated semantics.}

@section[:title "Operational Semantic Devices"]

@subsection[:title "Mathematical Preliminaries"]

@p{Define @m{\mathscr{B}} to be a Hilbert space isomorphic to
@m{\mathbb{C}^2}. Some texts refer to this space as a @emph{qubit}. We
may refer to it as a @emph{qubit space}.}

@p{We fix any orthonormal basis of @m{V := \mathscr{B}^{\otimes n}}
and call it the @emph{computational basis}. We use uppercase letters
to refer to the vector space and the corresponding lowercase indexed
letters with an overbar to refer to the computational basis elements
(e.g., @m{V} for the vector space and @m{\bar v_{*}} for the basis
elements). We order the computational basis as @m{\bar v_0} to @m{\bar
v_{2^n-1}} so the @m{k}th bit of the index (i.e., the coefficient of
@m{2^k}) of @m{\bar v_{*}} corresponds to the @m{0}th or @m{1}st basis
of the @m{k}th factor of @m{\mathscr{B}} from the right. For example,
let @m{n=3}, and let the left, middle, and right tensor factors of
@m{\mathscr{B}\otimes\mathscr{B}\otimes\mathscr{B}} be called @m{R},
@m{S}, and @m{T} respectively. Consider the basis element @m{\bar
v_4}. This index @m{4} is @c{100} in binary, and thus @m{\bar v_4}
corresponds to @m{\bar r_1\otimes \bar s_0\otimes \bar t_0}.}

@aside{Some texts might write @m{v_4} as either @m{\vert 001\rangle}
or @m{\vert 100\rangle}. We prefer the latter if we are to use Dirac
notation.}

@p{Given @m{V := \mathscr{B}}, we sometimes call @m{\bar v_0} the
@emph{ground state} or @emph{zero state}, and @m{\bar v_1} the
@emph{excited state} or @emph{one state}.}

@p{Define @m{\mathscr{U}(d)} to be the @emph{projective special
unitary group of dimension @m{d}}.}

@aside{Note that many texts write "PSU" instead of "U". We will often
say "unitary" when we really mean "projective special unitary".}

@subsection[:title "The Quantum Abstract Machine"]

@p{The semantics of Quil are defined operationally; that is, each
instruction of a Quil program is described by a change of some
state. This state is described by a mathematical object called the
"quantum abstract machine".}

@p{A @emph{quantum abstract machine} or @emph{QAM} is specified as:
@itemize{

    @item{A non-negative integer @m{N}, representing the number of
    qubits available to the machine; and a non-negative integer @m{M},
    representing the number of bits available to the machine;}

    @item{A pure quantum state (or @emph{wavefunction}) @m{\Psi},
    which is a vector in Hilbert space @m{\mathscr{B}^{\otimes N}};}

    @item{A classical state @m{C} of @m{M} ordered bits;}

    @item{A set @m{G} of static quantum gates, each of which is an
    element of @m{\mathscr{U}(2^N)}.}

    @item{A set @m{G'} of parametric quantum gates, each of which is a
    @m{k}-ary function @m{\mathbb{C}^k\to \mathscr{U}(2^N)}, where
    @m{k} can vary from gate to gate;}

    @item{A program @m{P} consisting of an ordered list of Quil
    instructions; and}

    @item{A program counter @m{0 \le \kappa \le \vert P\vert}
    represented as an integer indicating the "current" instruction.}
    }

This forms a @m{6}-tuple @m{(\Phi, C, G, G', P, \kappa)}. We may refer
to such a tuple as a QAM.}

@section[:title "Structure of a Quil Program"]

@subsection[:title "Syntactic Rudiments"]

@p{Before proceeding to describe each component of a Quil program, it
will be useful to establish a few common pieces of syntax which will
be used later.}

@p{The Quil language is represented as text. The text must be encoded
as UTF-8. The standard language constructs of Quil are all expressible
in the ASCII subset of UTF-8, but user programs may use codepoints
outside of UTF-8.}

@p{Except when noted explicitly, whitespace has no significance and is
ignored. Tokens can be separated by arbitrary amounts and kinds of
whitespace.}

@p{A newline is a single ASCII newline.}

@syntax[:name "Newline"]{
@syntax-descriptive{ASCII 10}
}

@p{A @emph{terminator} is used to terminate most components of a Quil
program syntactically.}

@syntax[:name "Terminator"]{
     @ms{Newline}
@alt ;
@alt @syntax-descriptive{End of File}
}

@p{An @emph{indent} is defined as exactly four spaces at the start of
a line. Indents in Quil programs can only happen following a newline.}

@syntax[:name "Indent"]{
    @ms{Newline}
    @rep[:min 4 :max 4]{@syntax-descriptive{ASCII 32}}
}

@p{Note that since indents must follow a newline, we include the
newline as a part of the syntax definition of an indent.}

@p{Non-negative integers are written as usual. Leading zeros do not
change the interpretation of these numeric literals.}

@syntax[:name "Non-Negative Integer"]{
    @rep[:min 1]{[0-9]}
}

@p{Real numbers are written in usual floating-point number syntax.}

@syntax[:name "Real"]{
  @rep[:min 0 :max 1]{@group{- @alt +}}
  @rep[:min 0 :max 1]{@ms{Non-Negative Integer}}
  @rep[:min 0 :max 1]{.}
  @ms{Non-Negative Integer}
  @rep[:min 0 :max 1]{
    @group{
      @group{e @alt E}
      @rep[:min 0 :max 1]{@group{- @alt +}}
      @ms{Non-Negative Integer}
    }
  }
}

@p{Complex numbers are an extension of this.}

@syntax[:name "Complex Number"]{
       @rep[:min 0 :max 1]{@group{- @alt +}} @ms{Non-Negative Integer}
  @alt @ms{Real}
  @alt @rep[:min 0 :max 1]{@ms{Real}} i
  @alt pi
}

@p{Strings are characters bounded by double-quotation mark characters
'@c{"}'. If a double-quotation mark should be used within the string,
it must be escaped with a backslash, like so: '@c{\"}'. Similarly, if
a backslash should be used within a string, it must be escaped, like
so: '@c{\\}'.}

@syntax[:name "String"]{
    "@rep{@group{[^\"] @alt \" @alt \\}}"
}

@p{Identifiers in Quil are alphanumeric Latin characters, along with
hyphens and underscores. Identifiers cannot start or end with a
hyphen '@c{-}'.}

@syntax[:name "Identifier"]{
         [A-Za-z_]
    @alt [A-Za-z_]@rep{[A-Za-z0-9\-_]}[A-Za-z0-9_]
}

@p{However, the following are @emph{not} identifiers:

@clist{
i pi
}
}

@p{The following identifiers are reserved (as Quil keywords):

@clist{
ADD AND AS CONTROLLED CONVERT DAGGER DECLARE DEFCIRCUIT DEFGATE DIV EQ
EXCHANGE FORKED GE GT HALT INCLUDE IOR JUMP JUMP-UNLESS JUMP-WHEN
LABEL LE LOAD LT MATRIX MEASURE MOVE MUL NEG NOP NOT OFFSET PAULI-SUM
PERMUTATION PRAGMA RESET SHARING STORE SUB WAIT XOR
}
}

@p{The following identifiers are also reserved (for standard gate
definitions):

@clist{
CAN CCNOT CNOT CPHASE CPHASE00 CPHASE01 CPHASE10 CSWAP CZ H I ISWAP
PHASE PISWAP PSWAP RX RY RZ S SWAP T X XY Y Z
}
}

@p{A @emph{formal parameter} is an identifier prefixed with a percent
sign, with no whitespace in between.}

@syntax[:name "Parameter"]{
    %@ms{Identifier}
}

@p{Multiple parameters may be separated by commas.}

@syntax[:name "Parameters"]{
    @rep[:min 0 :max 1]{
        @group{
            @ms{Parameter}
            @rep[:min 0]{
                @group{
                , @ms{Parameter}
                }
            }
        }
    }
}

@p{A @emph{formal argument} is simply an identifier.}

@syntax[:name "Argument"]{
    @ms{Identifier}
}

@p{Several formal arguments are separated by spaces, unlike
parameters.}

@syntax[:name "Arguments"]{
    @rep[:min 1]{@ms{Argument}}
}

@subsubsection[:title "Arithmetic Expressions"]

@p{Frequently, various kinds of arithmetic expressions are needed. A
simple and not unusual grammar defines these arithmetic expressions.}

@p{Depending on the specific grammatical context, arithmetic
expressions may or may not include references to formal parameters or
memory segments. Below, we define the grammar as including all of
these things, but certain contexts may disallow either or both of
them.}

@p{Precedence of binary operators is defined in the following
order of descending tightness. Along with the operators are their
associativity directions.

@clist{
^     RIGHT
* /   LEFT
+ -   LEFT
}
}

@syntax[:name "Expression"]{
         @ms{Expression} + @ms{Expression}
    @alt @ms{Expression} - @ms{Expression}
    @alt @ms{Expression} * @ms{Expression}
    @alt @ms{Expression} / @ms{Expression}
    @alt @ms{Expression} ^ @ms{Expression}
    @alt @ms{Term}
}

@syntax[:name "Term"]{
         - @ms{Expression}
    @alt @ms{Identifier} ( @ms{Expression} )
    @alt ( @ms{Expression} )
    @alt @ms{Non-Negative Integer}
    @alt @ms{Complex}
    @alt @ms{Parameter}
    @alt @ms{Memory Reference}
    @alt @ms{Identifier}
}

@p{A @emph{constant expression} is an arithmetic expression which does
not contain any parameters, memory references, or identifiers.}

@subsection[:title "Main Program Elements"]

@p{A Quil program consists of declarations, directives, and
instructions.}

@syntax[:name "Program"]{
@rep{@ms{Program Element}}
}

@syntax[:name "Program Element"]{
     @ms{Declaration} @group{@ms{Newline} @alt @syntax-descriptive{End of File}}
@alt @ms{Directive} @ms{Terminator}
@alt @ms{Instruction} @ms{Terminator}
}

@p{A @emph{declaration} typically specifies the existence of a named
object, like classical memory registers.}

@syntax[:name "Declaration"]{
     @ms{Gate Definition}
@alt @ms{Circuit Definition}
@alt @ms{Classical Memory Declaration}
}

@p{A @emph{directive} specifies information to software processing
Quil, such as the @quil{INCLUDE} directive for including files.}

@syntax[:name "Directive"]{
     @ms{Pragma}
@alt @ms{Label}
@alt @ms{File Include}
}

@p{An @emph{instruction} is an actual run-time executable effect.}

@syntax[:name "Instruction"]{
     @ms{Gate Application}
@alt @ms{Measurement Instruction}
@alt @ms{Circuit Application}
@alt @ms{Classical Memory Instruction}
@alt @ms{Reset Instruction}
@alt @ms{Wait Instruction}
@alt @ms{Branch Instruction}
@alt @ms{No-Operation Instruction}
@alt @ms{Halt Instruction}
}

@subsection[:title "Comments"]

@p{Comments may exist syntactically, but do not change the semantics
of the program. Text including and following the '@c{#}' character are ignored up
to the end of the line.}

@syntax[:name "Comment"]{
#@rep{[^\n]}
}

@p{There are no block comments.}


@section[:title "Quantum Gates"]

@subsection[:title "Qubits and Quantum State"]

@p{A Quil program manipulates quantum resources called @emph{qubits}. Qubits are indexed by non-negative integers.}

@syntax[:name "Qubit"]{
@ms{Non-Negative Integer}
}

@p{Qubit indexes have no significance on their own. Qubits must always
be referred to by their index. There is no bound on the number of
qubits in a Quil program, and any finite collection of qubits may
interact.}

@p{Quil has no ways to allocate an unbounded or non-deterministic
number of qubits at run-time. The number of qubits used by a program
can always be statically determined.}


@subsection[:title "Quantum Gate Definitions"]


@subsubsection[:title "Structure of a Gate Definition"]

@p{A gate definition allows us to name a unitary operation for
subsequent use in a program. A gate definition in general has the
following structure:}

@clist{
DEFGATE <name>(<params>) AS <kind>:
    <body>
}

@p{Here, the @c{<name>} names the gate, the @c{<kind>} states how we
are defining the gate, and the @c{<body>} depends on the @c{kind}. For
certain gates, @c{<params>} specifies parameters to the gate.}

@syntax[:name "Gate Definition"]{
     @ms{Matrix Gate Definition}
@alt @ms{Permutation Gate Definition}
@alt @ms{Pauli Sum Gate Definition}
}

@subsubsection[:title "Definition by Matrix"]

@p{A gate can be defined by its matrix of complex numbers represented
in the computational basis with the aforementioned ordering.}

@syntax[:name "Matrix Gate Definition"]{
DEFGATE @ms{Identifier}
@rep[:min 0 :max 1]{@group{(@ms{Parameters})}}
@rep[:min 0 :max 1]{@group{AS MATRIX}}:
@ms{Matrix Entries}
}

@p{A gate definitions with no parameters represents a static
gate. Otherwise it is a parametric gate.}

@p{For readability, matrix entries are typically broken up into
lines.}

@syntax[:name "Matrix Entries"]{
    @rep[:min 1]{@group{@ms{Indent}@ms{Matrix Entry Line}}}
}

@p{Each line contains a list of comma-separated arithmetic
expressions, most often simple integers or real numbers.}

@syntax[:name "Matrix Entry Line"]{
    @ms{Expression} @rep[:min 0]{@group{, @ms{Expression}}}
}

@p{The arithmetic expressions may either be constant or refer to the
parameters of the defined gate.}


@subsubsection[:title "Definition by Permutation"]

@p{A @emph{permutation gate} is one that permutes the coefficients of the wavefunction. A permutation @m{p} can be specified mathematically as an ordering of the integers between @m{0} and @m{n-1} written out as a list @dm{(p_1\;p_2\;\ldots\;p_n).} Here, @m{p} is a map on vectors such that if @m{x} is a column vector @dm{(x_1,\ldots,x_n)^{\intercal}} then @m{p(x)} is a column vector @dm{(x_{p_1}, x_{p_2}, \ldots, x_{p_n})^{\intercal}.} We specify permutation gates exactly by these numbers.}

@syntax[:name "Permutation Gate Definition"]{
DEFGATE @ms{Identifier} AS PERMUTATION:@ms{Indent}@ms{Permutation}
}

@p{Here, the permutation is a comma-separated list of non-negative
integers.}

@syntax[:name "Permutation"]{
    @ms{Non-Negative Integer}
    @rep[:min 1]{
    @group{
        ,
        @ms{Non-Negative Integer}
    }
    }
}

@p{There must be at least two integers specified, and the number of
integers specified must be a power-of-two.}

@subsubsection[:title "Definition by Pauli Sum"]

@syntax[:name "Pauli Sum Gate Definition"]{
DEFGATE @ms{Identifier} AS PAULI-SUM:@ms{Pauli Terms}
}

@syntax[:name "Pauli Terms"]{
    @rep[:min 1]{@group{@ms{Indent}@ms{Pauli Term}}}
}

@syntax[:name "Pauli Term"]{
    ...
}

@subsection[:title "Standard Gate Definitions"]

@subsection[:title "Quantum Gate Applications"]

@subsubsection[:title "Gate Modifiers"]

@section[:title "Quantum State Reset"]

@p{The quantum state may be reset to @m{\bar \psi_0} (i.e., all qubits in the ground state) by issuing a reset instruction.}

@syntax[:name "State Reset Instruction"]{
    RESET
}

@p{Instead, one may reset an individual qubit.}

@syntax[:name "Qubit Reset Instruction"]{
    RESET @ms{Qubit}
}

@p{This has the semantics corresponding to the following pseudo-code:}

@clist{
if 1 == MEASURE(qubit) then X(qubit)
}

@p{These make up the ways the quantum state may be reset.}

@syntax[:name "Reset Instruction"]{
         @ms{State Reset Instruction}
    @alt @ms{Qubit Reset Instruction}
}

@section[:title "Classical Memory"]

@section[:title "Measurement"]

;; measurement for effect
;; measurement for record

@section[:title "Classical Control"]

@subsection[:title "Halting the Program"]

@p{The program is @emph{halted} if it is no longer executing. This may happen under one of three conditions:
@itemize{
    @item{The @c{HALT} instruction was executed,}
    @item{The program counter reaches @m{\vert P\vert}, or}
    @item{An implementation-dependent error condition has happened.}
}}

@syntax[:name "Halt Instruction"]{
    HALT
}

@p{Error conditions may happen, for instance, when a division-by-zero
occurs. There may be other ways in which an implementation may error.}

@subsection[:title "Program Labels and Branching"]

@p{Run-time control flow is achieved through a variety of branching
instructions. Each branching instructions requires a target place in
the program to jump to. These target places are denoted by
@emph{labels}:}


@syntax[:name "Jump Target"]{
    @@@ms{Identifier}
}
@syntax[:name "Label"]{
    LABEL @ms{Jump Target}
}

@p{A label (resp. jump target) is said to be at position @m{p < \vert
P\vert} if the first instruction that follows the label (resp. jump
target's label) is the @m{p}th instruction (zero-indexed). If no
instruction follows the label, then it is said to be a @emph{halting
label at position @m{\vert P\vert}}.}

@p{One may transfer control to the @m{p}th position of a program by
using a @c{JUMP} instruction targeting a label at position @m{p}.}

@syntax[:name "Unconditional Branch Instruction"]{
    JUMP @ms{Jump Target}
}

@p{One may transfer control to the @m{p}th position of a program
conditional on a given memory reference using one of the following two
instructions:}

@syntax[:name "Conditional Branch Instruction"]{
         JUMP-WHEN @ms{Jump Target} @ms{Memory Reference}
    @alt JUMP-UNLESS @ms{Jump Target} @ms{Memory Reference}
}

@p{The @c{JUMP-WHEN} (resp. @c{JUMP-UNLESS}) instruction branches if
and only if @ms{Memory Reference} references a value that is non-zero
(resp. exactly zero).}

@p{Together, these form the branching instructions.}

@syntax[:name "Branch Instruction"]{
         @ms{Unconditional Branch Instruction}
    @alt @ms{Conditional Branch Instruction}
}

@section[:title "Other Instructions and Directives"]

@subsection[:title "No-Operation Instruction"]

@p{The @emph{no-operation instruction} or @emph{@c{NOP} instruction} is an instruction which does not affect the classical or quantum state of the QAM. It only affects the control state by incrementing the program counter by @m{1}.}

@syntax[:name "No-Operation Instruction"]{
    NOP
}

@subsection[:title "Pragmas"]

@p{Programs that process Quil code may want to take advantage of extra
information provided by the programmer. This is especially true when
targeting quantum processors where additional information about the
machineâ€™s characteristics affect how the program will be
processed. Quil supports a @c{PRAGMA} directive to include extra
information in a program which does not otherwise affect execution
semantics.}

@syntax[:name "Pragma"]{
    PRAGMA @ms{Identifier} @rep{@group{@ms{Identifier} @alt @ms{Integer}}} @rep[:max 1]{@ms{String}}
}

@subsection[:title "File Inclusion"]

@p{One can include a valid Quil file in another valid Quil file by
inclusion.}

@syntax[:name "File Include"]{
    INCLUDE @ms{String}
}

@p{Here, @ms{String} denotes a file name. Implementations processing
Quil must support and document individual file names, and may support
operating-system-dependent file paths.}

@section[:title "Test Area"]

@p{Let @m{a,b,c\in\mathbb{R}} in @dm{ax^2+bx+c=0,} which is a quadratic equation whose solutions are @dm{x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}.}}
