@section[:title "Introduction"]

@p{This is the language specification for Quil, a language for hybrid
classical/quantum computations.}

@p{Quil is an instruction-based language; each line of a Quil program
generally corresponds to a single, discrete action. Despite its
resemblance, Quil is @emph{not} an assembly language.}

@aside{An @emph{assembly language} is a textual format for the machine
code of a specific computer architecture. Quil is not that, and may be
used for a variety of quantum computer architectures.}

@p{This is an example Quil program that simulates a coin flip:

@clist{
DECLARE ro BIT[1]
H 0
MEASURE 0 ro[0]
}

Here, we can see the use of both classical data and quantum data. The
qubit numbered @c{0} is prepared in a uniform superposition by the
Hadamard gate @c{H}, and then measured in the computational basis,
depositing the resulting bit into a classic bit register named @c{ro}.
}

@p{The remainder of this document serves as a reference for all Quil
language syntax constructs and their associated semantics.}

@section[:title "Operational Semantic Devices"]

@subsection[:title "Mathematical Preliminaries"]

@p{Define @m{\mathscr{B}} to be a Hilbert space isomorphic to
@m{\mathbb{C}^2}. Some texts refer to this space as a @emph{qubit}. We
may refer to it as a @emph{qubit space}.}

@p{We fix any orthonormal basis of @m{V := \mathscr{B}^{\otimes n}}
and call it the @emph{computational basis}. We use uppercase letters
to refer to the vector space and the corresponding lowercase indexed
letters with an overbar to refer to the computational basis elements
(e.g., @m{V} for the vector space and @m{\bar v_{*}} for the basis
elements). We order the computational basis as @m{\bar v_0} to @m{\bar
v_{2^n-1}} so the @m{k}th bit of the index (i.e., the coefficient of
@m{2^k}) of @m{\bar v_{*}} corresponds to the @m{0}th or @m{1}st basis
of the @m{k}th factor of @m{\mathscr{B}} from the right. For example,
let @m{n=3}, and let the left, middle, and right tensor factors of
@m{\mathscr{B}\otimes\mathscr{B}\otimes\mathscr{B}} be called @m{R},
@m{S}, and @m{T} respectively. Consider the basis element @m{\bar
v_4}. This index @m{4} is @c{100} in binary, and thus @m{\bar v_4}
corresponds to @m{\bar r_1\otimes \bar s_0\otimes \bar t_0}.}

@aside{Some texts might write @m{v_4} as either @m{\vert 001\rangle}
or @m{\vert 100\rangle}. We prefer the latter if we are to use Dirac
notation.}

@p{Given @m{V := \mathscr{B}}, we sometimes call @m{\bar v_0} the
@emph{ground state} or @emph{zero state}, and @m{\bar v_1} the
@emph{excited state} or @emph{one state}.}

@p{Define @m{\mathscr{U}(d)} to be the @emph{projective special
unitary group of dimension @m{d}}.}

@aside{Note that many texts write "PSU" instead of "U". We will often
say "unitary" when we really mean "projective special unitary".}

@subsection[:title "The Quantum Abstract Machine"]

@p{The semantics of Quil are defined operationally; that is, each
instruction of a Quil program is described by a change of some
state. This state is described by a mathematical object called the
"quantum abstract machine".}

@p{A @emph{quantum abstract machine} or @emph{QAM} is specified as:
@itemize{

    @item{A non-negative integer @m{N}, representing the number of
    qubits available to the machine; and a non-negative integer @m{M},
    representing the number of bits available to the machine;}

    @item{A pure quantum state (or @emph{wavefunction}) @m{\Psi},
    which is a vector in Hilbert space @m{\mathscr{B}^{\otimes N}};}

    @item{A classical state @m{C} of @m{M} ordered bits;}

    @item{A set @m{G} of static quantum gates, each of which is an
    element of @m{\mathscr{U}(2^N)}.}

    @item{A set @m{G'} of parametric quantum gates, each of which is a
    @m{k}-ary function @m{\mathbb{C}^k\to \mathscr{U}(2^N)}, where
    @m{k} can vary from gate to gate;}

    @item{A program @m{P} consisting of an ordered list of Quil
    instructions; and}

    @item{A program counter @m{0 \le \kappa \le \vert P\vert}
    represented as an integer indicating the "current" instruction.}
    }

This forms a @m{6}-tuple @m{(\Phi, C, G, G', P, \kappa)}. We may refer
to such a tuple as a QAM.}

@section[:title "Structure of a Quil Program"]

@subsection[:title "Meta-Syntax"]

@p{In order to describe the syntax and semantics of a Quil program, we
use a syntax that is similar to @emph{extended Backus-Naur form},
though we deviate occasionally for convenience. While Quil's grammar
is context-free, specifying it is somewhat laborious due to the
possibility of identifiers being able to be used in some syntactic
constructs and other times not. As such, for syntactic constructs
which permit identifiers, we would need one set of productions, and
for those which don't, we would need another (nearly identical) set.}

@p{In order to avoid this laborious repetition, we write productions
of the grammar to always include sometimes forbidden elements, and
instead specify in the surrounding text the context in which those
elements are or are not allowed.}

@aside{When writing a recursive-descent parser, one would likely use
contextual flags to allow or disallow certain parsing rules, like
flags indicating the permission or lack thereof to use
identifiers. This leads to considerably shorter and clearer code.}

@subsection[:title "Syntactic Rudiments"]

@p{Before proceeding to describe each component of a Quil program, it
will be useful to establish a few common pieces of syntax which will
be used later.}

@p{The Quil language is represented as text. The text must be encoded
as UTF-8. The standard language constructs of Quil are all expressible
in the ASCII subset of UTF-8, but user programs may use codepoints
outside of UTF-8.}

@p{Except when noted explicitly, whitespace has no significance and is
ignored. Tokens can be separated by arbitrary amounts and kinds of
whitespace.}

@p{A newline is a single ASCII newline.}

@syntax[:name "Newline"]{
@syntax-descriptive{ASCII 10}
}

@p{A @emph{terminator} is used to terminate most components of a Quil
program syntactically.}

@syntax[:name "Terminator"]{
     @ms{Newline}
@alt ;
@alt @syntax-descriptive{End of File}
}

@p{An @emph{indent} is defined as exactly four spaces at the start of
a line. Indents in Quil programs can only happen following a newline.}

@syntax[:name "Indent"]{
    @ms{Newline}
    @rep[:min 4 :max 4]{@syntax-descriptive{ASCII 32}}
}

@p{Note that since indents must follow a newline, we include the
newline as a part of the syntax definition of an indent.}

@p{Non-negative integers are written as usual. Leading zeros do not
change the interpretation of these numeric literals.}

@syntax[:name "Non-Negative Integer"]{
    @rep[:min 1]{[0-9]}
}

@p{Real numbers are written in usual floating-point number syntax.}

@syntax[:name "Real"]{
  @rep[:min 0 :max 1]{@group{- @alt +}}
  @rep[:min 0 :max 1]{@ms{Non-Negative Integer}}
  @rep[:min 0 :max 1]{.}
  @ms{Non-Negative Integer}
  @rep[:min 0 :max 1]{
    @group{
      @group{e @alt E}
      @rep[:min 0 :max 1]{@group{- @alt +}}
      @ms{Non-Negative Integer}
    }
  }
}

@p{Complex numbers are an extension of this.}

@syntax[:name "Complex Number"]{
       @rep[:min 0 :max 1]{@group{- @alt +}} @ms{Non-Negative Integer}
  @alt @ms{Real}
  @alt @rep[:min 0 :max 1]{@ms{Real}} i
  @alt pi
}

@p{Strings are characters bounded by double-quotation mark characters
'@c{"}'. If a double-quotation mark should be used within the string,
it must be escaped with a backslash, like so: '@c{\"}'. Similarly, if
a backslash should be used within a string, it must be escaped, like
so: '@c{\\}'.}

@syntax[:name "String"]{
    "@rep{@group{[^\"] @alt \" @alt \\}}"
}

@p{Identifiers in Quil are alphanumeric Latin characters, along with
hyphens and underscores. Identifiers cannot start or end with a
hyphen '@c{-}'.}

@syntax[:name "Identifier"]{
         [A-Za-z_]
    @alt [A-Za-z_]@rep{[A-Za-z0-9\-_]}[A-Za-z0-9_]
}

@p{However, the following are @emph{not} identifiers:

@clist{
i pi
}
}

@p{The following identifiers are reserved (as Quil keywords):

@clist{
ADD AND AS CONTROLLED CONVERT DAGGER DECLARE DEFCIRCUIT DEFGATE DIV EQ
EXCHANGE FORKED GE GT HALT INCLUDE IOR JUMP JUMP-UNLESS JUMP-WHEN
LABEL LE LOAD LT MATRIX MEASURE MOVE MUL NEG NOP NOT OFFSET PAULI-SUM
PERMUTATION PRAGMA RESET SHARING STORE SUB WAIT XOR
}
}

@p{The following identifiers are also reserved (for standard gate
definitions):

@clist{
CAN CCNOT CNOT CPHASE CPHASE00 CPHASE01 CPHASE10 CSWAP CZ H I ISWAP
PHASE PISWAP PSWAP RX RY RZ S SWAP T X XY Y Z
}
}

@p{A @emph{formal parameter} is an identifier prefixed with a percent
sign, with no whitespace in between.}

@syntax[:name "Parameter"]{
    %@ms{Identifier}
}

@p{Multiple parameters may be separated by commas.}

@syntax[:name "Parameters"]{
    @rep[:min 0 :max 1]{
        @group{
            @ms{Parameter}
            @rep[:min 0]{
                @group{
                , @ms{Parameter}
                }
            }
        }
    }
}

@p{A @emph{formal argument} is simply an identifier.}

@syntax[:name "Argument"]{
    @ms{Identifier}
}

@p{Several formal arguments are separated by spaces, unlike
parameters.}

@syntax[:name "Arguments"]{
    @rep[:min 1]{@ms{Argument}}
}

@subsubsection[:title "Arithmetic Expressions"]

@p{Frequently, various kinds of arithmetic expressions are needed. A
simple and not unusual grammar defines these arithmetic expressions.}

@p{Depending on the specific grammatical context, arithmetic
expressions may or may not include references to formal parameters or
memory segments. Below, we define the grammar as including all of
these things, but certain contexts may disallow either or both of
them.}

@p{Precedence of binary operators is defined in the following
order of descending tightness. Along with the operators are their
associativity directions.

@clist{
^     RIGHT
* /   LEFT
+ -   LEFT
}
}

@syntax[:name "Expression"]{
         @ms{Expression} + @ms{Expression}
    @alt @ms{Expression} - @ms{Expression}
    @alt @ms{Expression} * @ms{Expression}
    @alt @ms{Expression} / @ms{Expression}
    @alt @ms{Expression} ^ @ms{Expression}
    @alt @ms{Term}
}

@syntax[:name "Term"]{
         - @ms{Expression}
    @alt @ms{Identifier} ( @ms{Expression} )
    @alt ( @ms{Expression} )
    @alt @ms{Non-Negative Integer}
    @alt @ms{Complex}
    @alt @ms{Parameter}
    @alt @ms{Memory Reference}
    @alt @ms{Identifier}
}

@p{A @emph{constant expression} is an arithmetic expression which does
not contain any parameters, memory references, or identifiers.}

@p{We use comma-separated lists of arithmetic expressions frequently
enough to warrant their own production.}

@syntax[:name "Expression List"]{
    @ms{Expression}
    @rep[:min 0]{
        @group{
            ,
            @ms{Expression}
        }
    }
}

@subsection[:title "Main Program Elements"]

@p{A Quil program consists of declarations, directives, and
instructions.}

@syntax[:name "Program"]{
@rep{@ms{Program Element}}
}

@syntax[:name "Program Element"]{
     @ms{Declaration} @group{@ms{Newline} @alt @syntax-descriptive{End of File}}
@alt @ms{Directive} @ms{Terminator}
@alt @ms{Instruction} @ms{Terminator}
}

@p{A @emph{declaration} typically specifies the existence of a named
object, like classical memory registers.}

@syntax[:name "Declaration"]{
     @ms{Gate Definition}
@alt @ms{Circuit Definition}
@alt @ms{Classical Memory Declaration}
}

@p{A @emph{directive} specifies information to software processing
Quil, such as the @quil{INCLUDE} directive for including files.}

@syntax[:name "Directive"]{
     @ms{Pragma}
@alt @ms{Label}
@alt @ms{File Include}
}

@p{An @emph{instruction} is an actual run-time executable effect.}

@syntax[:name "Instruction"]{
     @ms{Gate Application}
@alt @ms{Measurement Instruction}
@alt @ms{Circuit Application}
@alt @ms{Classical Memory Instruction}
@alt @ms{Reset Instruction}
@alt @ms{Wait Instruction}
@alt @ms{Branch Instruction}
@alt @ms{No-Operation Instruction}
@alt @ms{Halt Instruction}
}

@subsection[:title "Comments"]

@p{Comments may exist syntactically, but do not change the semantics
of the program. Text including and following the '@c{#}' character are ignored up
to the end of the line.}

@syntax[:name "Comment"]{
#@rep{[^\n]}
}

@p{There are no block comments.}


@section[:title "Quantum Gates"]

@subsection[:title "Qubits and Quantum State"]

@p{A Quil program manipulates quantum resources called @emph{qubits}. Qubits are indexed by non-negative integers.}

@syntax[:name "Qubit"]{
@ms{Non-Negative Integer}
}

@p{Qubit indexes have no significance on their own. Qubits must always
be referred to by their index. There is no bound on the number of
qubits in a Quil program, and any finite collection of qubits may
interact.}

@p{Quil has no ways to allocate an unbounded or non-deterministic
number of qubits at run-time. The number of qubits used by a program
can always be statically determined.}

@p{Sometimes, a qubit may instead have a formal argument in its
place. This may not be possible in all cases.}

@syntax[:name "Formal Qubit"]{
         @ms{Qubit}
    @alt @ms{Parameter}
}

@subsection[:title "Quantum Gate Definitions"]

@subsubsection[:title "Structure of a Gate Definition"]

@p{A gate definition allows us to name a unitary operation for
subsequent use in a program. A gate definition in general has the
following structure:}

@clist{
DEFGATE <name>(<params>) AS <kind>:
    <body>
}

@p{Here, the @c{<name>} names the gate, the @c{<kind>} states how we
are defining the gate, and the @c{<body>} depends on the @c{kind}. For
certain gates, @c{<params>} specifies parameters to the gate.}

@syntax[:name "Gate Definition"]{
     @ms{Matrix Gate Definition}
@alt @ms{Permutation Gate Definition}
@alt @ms{Pauli Sum Gate Definition}
}

@subsubsection[:title "Definition by Matrix"]

@p{A gate can be defined by its matrix of complex numbers represented
in the computational basis with the aforementioned ordering.}

@syntax[:name "Matrix Gate Definition"]{
DEFGATE @ms{Identifier}
@rep[:min 0 :max 1]{@group{(@ms{Parameters})}}
@rep[:min 0 :max 1]{@group{AS MATRIX}}:
@ms{Matrix Entries}
}

@p{A gate definitions with no parameters represents a static
gate. Otherwise it is a parametric gate.}

@p{For readability, matrix entries are typically broken up into
lines.}

@syntax[:name "Matrix Entries"]{
    @rep[:min 1]{@group{@ms{Indent}@ms{Matrix Entry Line}}}
}

@p{Each line contains a list of comma-separated arithmetic
expressions, most often simple integers or real numbers.}

@syntax[:name "Matrix Entry Line"]{
    @ms{Expression} @rep[:min 0]{@group{, @ms{Expression}}}
}

@p{The arithmetic expressions may either be constant or refer to the
parameters of the defined gate.}


@subsubsection[:title "Definition by Permutation"]

@p{A @emph{permutation gate} is one that permutes the coefficients of
the wavefunction. A permutation @m{p} can be specified mathematically
as an ordering of the integers between @m{0} and @m{n-1} written out
as a list @dm{(p_1\;p_2\;\ldots\;p_n).} Here, @m{p} is a map on
vectors such that if @m{x} is a column vector
@dm{(x_1,\ldots,x_n)^{\intercal}} then @m{p(x)} is a column vector
@dm{(x_{p_1}, x_{p_2}, \ldots, x_{p_n})^{\intercal}.} We specify
permutation gates exactly by these numbers.}

@syntax[:name "Permutation Gate Definition"]{
DEFGATE @ms{Identifier} AS PERMUTATION:@ms{Indent}@ms{Permutation}
}

@p{Here, the permutation is a comma-separated list of non-negative
integers.}

@syntax[:name "Permutation"]{
    @ms{Non-Negative Integer}
    @rep[:min 1]{
    @group{
        ,
        @ms{Non-Negative Integer}
    }
    }
}

@p{There must be at least two integers specified, and the number of
integers specified must be a power-of-two.}

@subsubsection[:title "Definition by Pauli Sum"]

@syntax[:name "Pauli Sum Gate Definition"]{
DEFGATE @ms{Identifier} AS PAULI-SUM:@ms{Pauli Terms}
}

@syntax[:name "Pauli Terms"]{
    @rep[:min 1]{@group{@ms{Indent}@ms{Pauli Term}}}
}

@syntax[:name "Pauli Term"]{
    ...
}

@subsection[:title "Standard Gate Definitions"]

@subsection[:title "Quantum Gate Applications"]


@p{TODO: allow formal arguments}

@syntax[:name "Gate Application"]{
    @rep[:min 0]{@ms{Modifier}}
    @ms{Identifier}
    @rep[:min 0 :max 1]{
        @group{
            (
                @rep[:min 0 :max 1]{@ms{Expression List}}
            )
        }
    }
    @rep[:min 1]{@ms{Formal Qubit}}
}


@subsubsection[:title "Gate Modifiers"]

@section[:title "Quantum State Reset"]

@p{The quantum state may be reset to @m{\bar \psi_0} (i.e., all qubits
in the ground state) by issuing a reset instruction.}

@syntax[:name "State Reset Instruction"]{
    RESET
}

@p{Instead, one may reset an individual qubit.}

@syntax[:name "Qubit Reset Instruction"]{
    RESET @ms{Formal Qubit}
}

@p{This has the semantics corresponding to the following pseudo-code:}

@clist{
if 1 == MEASURE(qubit) then X(qubit)
}

@p{These make up the ways the quantum state may be reset.}

@syntax[:name "Reset Instruction"]{
         @ms{State Reset Instruction}
    @alt @ms{Qubit Reset Instruction}
}

@section[:title "Classical Memory"]

@p{This section explains Quil's classical memory model.}

@subsection[:title "Design Considerations"]

@emph{This section is descriptive and not normative.}

@p{In assembly code, in general, types are considered only at the
mnemonic or interpretation level. They're not often a consideration in
the code itself. (Though this is not always true, machine codes for
dynamic languages included the notion of type checking and type tags
at the instruction level.) On modern processor architectures, one has
a large @emph{random access memory} (RAM) which is byte-addressable,
and a series of processor @emph{registers} that hold usually one
word's worth of data. (A @emph{word} is often some multiple of bytes,
usually 4 or 8.) A @emph{register machine} is one that loads values
from memory to the registers, does some operation, and often stores
the results back into memory.}

@p{So far, we've spoken only of bytes or multiples thereof. A byte—or
word for that matter—is simply a measure of a number of bits, with no
additional attached interpretation. What gives a byte interpretation
is the literal machinery attached to the registers in which the bytes
are stored. Implicit in the machinery, usually electrical circuitry,
is a way of transforming bytes into a new ones. This machinery is
invoked with an @emph{opcode}. Since opcodes relate to physical machinery,
opcodes are often only pertinent to a subset of registers that a
machine has. From here, we get a usual partitioning of registers:
registers that deal with general integer arithmetic, registers that
deal with floating point numbers, registers that deal with vectorized
low-precision arithmetic, registers that interact with main memory,
and so on. The partition isn't always so strict; @emph{general purpose
registers} often are capable of many disparate operations.}

@p{RAM more often than not lacks any serious kind of operation except
loading and storing. Similarly, cross-register opcodes also deal with
the movement of data and not operation on the data contained
within. When we want to do something like adding an integer and
floating point number, we have to put the integer into a floating
point representation, move it from an integer register to a floating
point register, and perform the addition across two floating point
registers. Some architectures, such as the x87 floating point unit,
can perform the representation-changing and loading in a single
instruction (e.g., the @c{FILD} instruction).}

@p{Quil was designed to be an instruction language that doesn't
conform to any physical architecture. It was designed to accommodate
evolving quantum architectures in terms of their memory models and
their native gates. In some sense, Quil can be seen as a portable
bytecode of sorts, (currently) without an actual byte-code
representation.}

@p{The original 2016 Quil paper assumes there is an unbounded classical
memory composed of a series of bits, and segments of these bits can be
interpreted as a real or complex number. While very simplistic, it has
a few flaws:

@itemize{
    @item{The type of a data segment is determined solely by its
    length (64 bits indicates a double-precision floating point
    number, 128 bits indicates a double-precision complex number).}

    @item{There are no provisions for the construction or use of
    integer data, which is desirable for counters and frequentist
    statistics.}

    @item{There are no classical instructions that make use of
    segments, despite an inherent desire to do high-speed arithmetic
    on gate angles.}

    @item{Quil code making heavy use of segments quickly becomes
    unwieldy and unreadable.}

    @item{Quil code has no friendly notion of @emph{linkage}, which
    would allow a concurrently run classical program to refer to named
    data.}
}
}

@p{In the remainder of this section, we describe a replacement for the
notion of classical data in Quil. It is similar to C in that we don't
select any particular memory model, and require the user to specify
what he or she requires in terms of layout. Similarly departing from
usual instruction sets, we allow for memory to be interpreted through
multiple type lenses. In C, we accomplish this by casting pointers and
dereferencing. Since we don't have a notion of pointers, we accomplish
this with explicit declaration and aliasing.}

@p{With Quil's classical memory model, we can write code which does
the following:

@clist{
DECLARE count INTEGER
DECLARE stats INTEGER
DECLARE measurement INTEGER
DECLARE angle REAL
DECLARE cond BIT

# Initialize
MOVE stats 0
MOVE angle 0.0

# Start the angle loop
LABEL @@start_angle_loop
LT cond angle 6.283185307179586
JUMP-UNLESS @@end cond
# Perform histogram loop, 1000 shots
MOVE count 1000
LABEL @@stats_loop
RX(angle) 0
MEASURE 0 measurement
ADD stats measurement
SUB count 1
GT cond count 0
JUMP-WHEN @@stats_loop cond
# Calculate next angle
ADD angle 0.3926990816987241   # pi/8
JUMP @@start_angle_loop
LABEL @@end
}
}

@p{This will be roughly equivalent to the following C program:

@clist{
int count, stats, measurement;
float angle;
stats = 0;
for(angle = 0.0; angle < 6.283185307179586; angle += 0.3926990816987241) {
    for(count = 1000; count > 0; count--) {
        RX(angle) 0
        measurement = MEASURE 0
        stats += measurement
    }
}
}
}


@subsection[:title "Types"]

@p{The supported types are @c{BIT} which represents one bit, @c{OCTET}
which represents 8 bits, @c{INTEGER} which represents a machine-sized
signed integer, and @c{REAL} which represents a machine-sized real
number. The formats/layouts of these are specific to the machine being
run on.}

@syntax[:name "Base Type"]{
        BIT
   @alt OCTET
   @alt INTEGER
   @alt REAL
}

@p{When we speak of @emph{size}, we mean the number of octets that a
type represents. The notion of @emph{size} is distinct from
@emph{length}, which instead refers to some count of elements of a
particular type.}

@p{A fixed-length vector of a type is denoted by the type name
followed by an integer in brackets. For instance, @c{REAL[5]} is a
type that represents five real numbers in sequence. The type
@c{INTEGER} is guaranteed to be large enough to hold a valid length of
octets, and is guaranteed to hold at least the values @m{-127} to
@m{128}.}

@syntax[:name "Type"]{
        @ms{Base Type}
   @alt @ms{Base Type}[@ms{Non-Negative Integer}]
}

@p{There are currently no provisions for adding additional types.}

@subsection[:title "Declaring Memory"]

@p{Quil doesn't have a notion of @emph{allocating} memory, but rather
the notion of @emph{declaring the existence} of memory. In the
following, we introduce the @c{DECLARE} directive, which describes
available memory for a program to use.}

@p{Some quantum computing architectures might restrict what can be
declared, what types can be used, what names can be used, etc. It is
recommended to be as liberal as possible in what can be declared,
while remaining true to the architectural constraints of the system on
which Quil is executed.}

@p{The @c{DECLARE} directive is used to declare a vector of typed
memory. There are three variants: plain declaration, aliased
declaration, and aliased declaration with offset.}

@syntax[:name "Classical Memory Declaration"]{
         @ms{Plain Memory Declaration}
    @alt @ms{Aliased Memory Declaration}
    @alt @ms{Offset Memory Declaration}
}

@subsubsection[:title "Declaring Memory"]

@syntax[:name "Plain Memory Declaration"]{
    DECLARE @ms{Identifier} @ms{Type}
}

@p{This declares that @ms{Identifier} designates memory which can hold
@ms{Type}. If @ms{Type} is a scalar type, then it is assumed to
designate a vector of length 1. That is, the following two lines are
equivalent:

@clist{
DECLARE x INTEGER
DECLARE x INTEGER[1]
}
}

@p{In the program that would follow either of these declarations,
@c{x} or equivalently @c{x[0]} will refer to an integer quantity.}

@subsubsection[:title "Declaring Aliased Memory"]

@syntax[:name "Aliased Memory Declaration"]{
DECLARE @ms[:sub 1]{Identifier} @ms{Type} SHARING @ms[:sub 2]{Identifier}
}

@p{This declares that @ms[:sub 1]{Identifier} designates memory which can hold
@ms{Type}, but @ms[:sub 1]{Identifier} shares memory with that which is designated
by @ms[:sub 2]{Identifier}. Here, the total memory size pointed to by
@ms[:sub 1]{Identifier} shall not exceed the total memory size pointed to by
@ms[:sub 2]{Identifier}.}

@p{An implementation is free to reject programs where particular
instances of sharing is invalid (e.g., alignment is violated;
disparate memories are unshareable; etc.).}

@subsubsection[:title "Declaring Aliased Memory Declaration with an Offset"]

@syntax[:name "Offset Memory Declaration"]{
DECLARE @ms[:sub 1]{Identifier}
        @ms{Type}
        SHARING @ms[:sub 2]{Identifier}
        OFFSET
        @rep[:min 1]{
          @group{
            @ms[:sub "i"]{Non-Negative Integer}
            @ms[:sub "i"]{Type}
          }
        }
}

@p{This is similar to the aliased declaration, but it allows
@ms[:sub 1]{Identifier} to designate memory in the middle of that which is
designated by @ms[:sub 2]{Identifier}. In particular, @ms[:sub 1]{Identifier} will point
to memory a total of @dm{\sum_i \langle\texttt{Non-Negative Integer}_i\rangle\cdot
\text{sizeof}(\langle\texttt{Type}_i\rangle)} bits after the start of
@ms[:sub 2]{Identifier}. As with an aliased declaration, the memory at
@ms[:sub 1]{Identifier} must not overflow the end of @ms[:sub 2]{Identifier}.}

@p{Implementations may enforce alignment by way of erroring if the
stated declaration is invalid. Implementations must @emph{not} round
up or down to alignment boundaries.}

@subsubsection[:title "Portability of Aliased Declarations"]

@p{Aliased declarations with mixed types require an intimate view of
the target architecture. The widths of each data type, which are
hitherto unspecified, must be known. For example, the following
declarations may not be valid of the size of @c{REAL} exceeds the size
of @c{INTEGER}.

@clist{
DECLARE x INTEGER
DECLARE y REAL SHARING x
}

Even if such a declaration is valid, operations on @c{y} are not
portably specified. For example, continuing the above,

@clist{
DECLARE b BIT
MOVE x 0
EQ b y 0.0
}

could result in any value for @c{b}, depending on the implementation.
}

@p{An implementation shall describe the bit-level description of the
types, the available declarable memories, the limits on the declared
memory, alignment requirements, and limits on sharing and offsets.}

@subsubsection[:title "Examples"]

@subsubsubsection[:title "Register Machine with a Condition Bit"]

@p{Here we consider a layout for a machine that has one integer
register, two real registers, and a @emph{condition bit} used for
doing comparisons and branching.

@clist{
DECLARE f1 REAL
DECLARE f2 REAL
DECLARE x INTEGER
DECLARE cmp BIT    # cmp for "comparison"
}
}

@p{This might be suitable for a very simple quantum control system
with a single counter for loops.}

@subsubsubsection[:title "Memory-Mapped RAM"]

@p{The following is an example of a memory structure that might be
used in a system with a fixed and known memory layout optimized for
running QAOA-like circuits.

@clist{
DECLARE memory OCTET[131072]                              # 128k global memory
DECLARE qaoa-params REAL[32] SHARING memory               # all QAOA params
DECLARE beta REAL[16] SHARING qaoa-params                 # beta params
DECLARE gamma REAL[16] SHARING qaoa-params OFFSET 16 REAL # gamma params
DECLARE ro BIT[16]                                        # readout registers
}
}

@p{Here, we have two disjoint memories: the global data memory
@c{memory}, and the readout memory @c{ro}. We see that the global data
memory @c{memory} is further partitioned into a section
@c{qaoa-params} specifically for QAOA parameters, which may be useful
if you're changing them all at once. Nonetheless, for actual use in
Quil code, the actual @c{beta} and @c{gamma} parameters are carved out
of this memory.}

@p{This particular scheme may be necessary if software processing Quil
does not have any ability generate memory maps automatically. If that
functionality were possible, one could simply declare @c{beta},
@c{gamma}, and @c{ro} and let the compilation software take care of
mapping that to physical memory.}

@subsubsubsection[:title "Computing Bits of an Angle"]

@p{In algorithms like phase estimation, we compute one bit of the result
at a time with each measurement. If our @c{INTEGER} data type has the
standard binary representation, then one can do:

@clist{
DECLARE unadjusted-theta INTEGER
DECLARE ro BIT[16] SHARING unadjusted-theta
DECLARE theta REAL
# <phase estimation>
MEASURE 0 ro[0]
MEASURE 1 ro[1]
# ...
MEASURE 15 ro[15]
}
}

@p{Here, we have a 16-bit integer @c{unadjusted-theta} with the LSB of
our estimated phase starting with qubit 0. (This depends on our
convention in our implementation of phase estimation.) Since
@c{unadjusted-theta} and @c{ro} are shared, the bits of @c{ro}
directly affect the bits of our integer. Recalling that phase
estimation gives us a bitstring (in this case, an integer between
@m{0} and @m{2^{16} - 1}), we must actually adjust it by multiplying by
@m{2\pi/2^{16}}, which is approximately @m{9.587379924285257\times
10^{-5}}.}

@p{Since @c{theta} and @c{unadjusted-theta} have different types, we
can't quite yet do this multiplication. We need to convert
@c{unadjusted-theta} into a @c{REAL} representation on which we can do
fractional arithmetic. We can do this with @c{CONVERT}, which in other
languages is known as a @emph{cast} or @emph{coercion}.

@clist{
CONVERT theta unadjusted-theta   # convert INTEGER to REAL
MUL     theta theta 9.587379924285257e-5
}
}

@p{Now we can use @c{theta} as an argument to an angle if we
please. For example, we might do a phase adjustment based off of that
angle on qubit @c{16}:

@clist{
RZ(theta) 16
}
}

@subsection[:title "Memory Access and Dereferencing"]

@p{Memory is dereferenced in a Quil program using common array
access syntax. In particular, given a name @c{x} pointing to
memory of type @m{T}, and a non-negative integer offset @m{n}, the
syntax @c{x[@m{n}]} refers to the @m{n}th element of type @m{T} indexing
off of @c{x[0]}.}

@p{If and only if @c{x} was declared with just a single element, then
@c{x} may be referred to simply by its name with no bracket. In this
case, @c{x} and @c{x[0]} would be equivalent.}

@syntax[:name "Memory Reference"]{
         @ms{Identifier}
    @alt @ms{Identifier}[@ms{Non-Negative Integer}]
}

@p{Dereferencing with indirection, e.g., something akin to
@c{x[y[3]]}, is supported through the @c{LOAD} and @c{STORE}
instructions. For example,

@clist{
DECLARE x INTEGER[16]
DECLARE y INTEGER[16]
DECLARE z INTEGER[16]
DECLARE t INTEGER
LOAD t y z[3]          # t := y[z[3]]
LOAD t x t             # t := x[t]
}
}

@subsection[:title "Classical Instructions"]

@p{With typed memory comes a bag of new instructions. Classical
instructions come in unary (single-argument), binary
(double-argument), and ternary (triple-argument) forms. They all share
the same syntax.}

@syntax[:name "Classical Memory Instruction"]{
         @ms{Classical Unary} @ms{Memory Reference}
    @alt @ms{Classical Binary} @rep[:min 2 :max 2]{@ms{Memory Reference}}
    @alt @ms{Classical Ternary} @rep[:min 3 :max 3]{@ms{Memory Reference}}
}

@p{The unary instruction names are:}

@syntax[:name "Classical Unary"]{
    NOT @alt NEG
}

@p{The binary instruction names are:}

@syntax[:name "Classical Binary"]{
         MOVE @alt EXCHANGE @alt CONVERT
    @alt AND @alt IOR @alt XOR
    @alt ADD @alt SUB @alt MUL @alt DIV
}

@p{The ternary instruction names are:}

@syntax[:name "Classical Ternary"]{
    LOAD @alt STORE @alt EQ @alt GT @alt GE @alt LT @alt LE
}

@p{While the instructions all take memory references, they only take
memory references of certain type combinations. Each combination is
called an "instruction mode". In the following table, we use the
following notation to denote an instruction @c{INSTR} and its modes:

@clist{
# Category of instruction
INSTR   a b             # Pseudocode meaning
        <type1a> <type1b>
        <type2a> <type2b>
        ...
}
}

@p{The possibilities for @c{<typeXY>} are:

@itemize{
@item{@c{<!int>}  : Immediate (literal) integer, also used for octets (@c{0} to @c{255}) and bits (@c{0} and @c{1})}
@item{@c{<int>}   : Memory reference to an integer}
@item{@c{<int*>}  : Name of a vector of declared integers}
@item{@c{<!real>} : Immediate (literal) real}
@item{@c{<real>}  : Memory reference to a real}
@item{@c{<real*>} : Name of a vector of declared reals}
@item{@c{<bit>}   : Memory reference to a bit}
@item{@c{<bit*>}  : Name of a vector of declared bits}
@item{@c{<oct>}   : Memory reference to an octet}
@item{@c{<oct*>}  : Name of a vector of declared octets}
}
}

@p{Octet literals share the same syntax as integer literals.}

@p{We generally follow the @c{dest}-@c{src} ordering of arguments.}

@clist{
# Move like-typed data to different locations.
# Also allows loading immediate values.
MOVE     a b            # a := b; Store contents of b at a
         <oct> <!int>
         <oct> <oct>
         <int> <!int>
         <int> <int>
         <real> <!real>
         <real> <real>
         <bit> <!int>
         <bit> <bit>

# Exchange the value at two like-typed locations.
EXCHANGE a b            # Exchange contents of a and b; a <=> b
         <oct> <oct>
         <int> <int>
         <real> <real>
         <bit> <bit>

# Perform an indirect load from x offset by n to a.
LOAD     a x n          # a := x[n]
         <oct> <oct*> <int>
         <int> <int*> <int>
         <real> <real*> <int>
         <bit> <bit*> <int>

# Perform an indirect store of a to x offset by n.
STORE    x n a          # x[n] := a
         <oct*> <int> <oct>
         <oct*> <int> <!int>
         <int*> <int> <int>
         <int*> <int> <!int>
         <real*> <int> <real>
         <real*> <int> <!real>
         <bit*> <int> <bit>
         <bit*> <int> <!int>

# Perform a move of differently typed data.
# The data here is interpreted numerically.
CONVERT  a b            # a := (T)b, where T = type-of(a)
         <int> <real>   # - Best integer approximation of a real.
         <int> <bit>    # - Convert 0 or 1 to an integer.
         <real> <int>   # - Best real approximation of an integer.
         <real> <bit>   # - Convert 0 or 1 to a real.
         <bit> <int>    # - 0 if 0, 1 if non-zero.
         <bit> <real>   # - 0 if 0.0, 1 if non-zero

# Logical Operations
NOT      a              # a := ~a
         <oct>
         <int>
         <bit>

AND      a b            # a := a & b
IOR      a b            # a := a | b
XOR      a b            # a := a ^ b
         <oct> <oct>
         <oct> <!int>
         <int> <int>
         <int> <!int>
         <bit> <bit>
         <bit> <!int>

# Arithmetic Operations
NEG      a              # a := -a
         <int>
         <real>

ADD      a b            # a := a + b 
SUB      a b            # a := a - b
MUL      a b            # a := a * b
DIV      a b            # a := a / b
         <int> <int>
         <int> <!int>
         <real> <!real>
         <real> <real>

# Comparison
EQ       r a b          # r := (a == b)
GT       r a b          # r := (a > b)
GE       r a b          # r := (a >= b)
LT       r a b          # r := (a < b)
LE       r a b          # r := (a <= b)
         <bit> <bit> <bit>
         <bit> <bit> <!int>
         <bit> <oct> <oct>
         <bit> <oct> <!int>
         <bit> <int> <int>
         <bit> <int> <!int>
         <bit> <real> <real>
         <bit> <real> <!real>
}



@section[:title "Measurement"]

@p{Measurement is the only way in which the quantum state can affect
classical memory. Measurement comes in two flavors:
@emph{measurement-for-effect} and @emph{measurement-for-record}.}

@p{Measurement-for-effect measures a single qubit and discards the
result.}

@syntax[:name "Measurement for Effect"]{
    MEASURE @ms{Formal Qubit}
}

@p{Measurement will stochastically project the qubit into either the
zero-state or the one-state depending on its probability of such
dictated by the wavefunction amplitudes.}

@syntax[:name "Measurement for Record"]{
    MEASURE @ms{Formal Qubit} @ms{Memory Reference}
}

@p{Here, the memory reference must be either of type @c{BIT} or
@c{INTEGER}. In either case, a @m{0} is deposited at the memory
location if the qubit was measured to be in the zero-state, and a
@m{1} otherwise.}

@p{These measurement varieties make up all measurement instructions.}

@syntax[:name "Measurement Instruction"]{
         @ms{Measurement for Effect}
    @alt @ms{Measurement for Record}
}

@p{Note that there is no way in Quil to measure all qubits
simultaneously.}

@section[:title "Classical Control"]

@subsection[:title "Halting the Program"]

@p{The program is @emph{halted} if it is no longer executing. This may
happen under one of three conditions:

@itemize{
    @item{The @c{HALT} instruction was executed,}
    @item{The program counter reaches @m{\vert P\vert}, or}
    @item{An implementation-dependent error condition has happened.}
}}

@syntax[:name "Halt Instruction"]{
    HALT
}

@p{Error conditions may happen, for instance, when a division-by-zero
occurs. There may be other ways in which an implementation may error.}

@subsection[:title "Program Labels and Branching"]

@p{Run-time control flow is achieved through a variety of branching
instructions. Each branching instructions requires a target place in
the program to jump to. These target places are denoted by
@emph{labels}:}


@syntax[:name "Jump Target"]{
    @@@ms{Identifier}
}
@syntax[:name "Label"]{
    LABEL @ms{Jump Target}
}

@p{A label (resp. jump target) is said to be at position @m{p < \vert
P\vert} if the first instruction that follows the label (resp. jump
target's label) is the @m{p}th instruction (zero-indexed). If no
instruction follows the label, then it is said to be a @emph{halting
label at position @m{\vert P\vert}}.}

@p{One may transfer control to the @m{p}th position of a program by
using a @c{JUMP} instruction targeting a label at position @m{p}.}

@syntax[:name "Unconditional Branch Instruction"]{
    JUMP @ms{Jump Target}
}

@p{One may transfer control to the @m{p}th position of a program
conditional on a given memory reference using one of the following two
instructions:}

@syntax[:name "Conditional Branch Instruction"]{
         JUMP-WHEN @ms{Jump Target} @ms{Memory Reference}
    @alt JUMP-UNLESS @ms{Jump Target} @ms{Memory Reference}
}

@p{The @c{JUMP-WHEN} (resp. @c{JUMP-UNLESS}) instruction branches if
and only if @ms{Memory Reference} references a @bit{BIT}-typed value
that is non-zero (resp. exactly zero).}

@p{Together, these form the branching instructions.}

@syntax[:name "Branch Instruction"]{
         @ms{Unconditional Branch Instruction}
    @alt @ms{Conditional Branch Instruction}
}

@section[:title "Other Instructions and Directives"]

@subsection[:title "No-Operation Instruction"]

@p{The @emph{no-operation instruction} or @emph{@c{NOP} instruction} is an instruction which does not affect the classical or quantum state of the QAM. It only affects the control state by incrementing the program counter by @m{1}.}

@syntax[:name "No-Operation Instruction"]{
    NOP
}

@subsection[:title "Pragmas"]

@p{Programs that process Quil code may want to take advantage of extra
information provided by the programmer. This is especially true when
targeting quantum processors where additional information about the
machine’s characteristics affect how the program will be
processed. Quil supports a @c{PRAGMA} directive to include extra
information in a program which does not otherwise affect execution
semantics.}

@syntax[:name "Pragma"]{
    PRAGMA @ms{Identifier} @rep{@group{@ms{Identifier} @alt @ms{Integer}}} @rep[:max 1]{@ms{String}}
}

@subsection[:title "File Inclusion"]

@p{One can include a valid Quil file in another valid Quil file by
inclusion.}

@syntax[:name "File Include"]{
    INCLUDE @ms{String}
}

@p{Here, @ms{String} denotes a file name. Implementations processing
Quil must support and document individual file names, and may support
operating-system-dependent file paths.}

@section[:title "Test Area"]

@p{Let @m{a,b,c\in\mathbb{R}} in @dm{ax^2+bx+c=0,} which is a quadratic equation whose solutions are @dm{x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}.}}
