<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
<!-- This document was automatically generated on 2022-02-22T12:41:19.440570-08:00. -->
  <head>
    <link rel='stylesheet' type='text/css' href='style.css' />
    <script src='https://polyfill.io/v3/polyfill.min.js?features=es6'></script>
    <script id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'></script>
    <title>Quil Specification
    </title>
  </head>
  <body>
    <h1>Quil Specification
    </h1>
    <p>
      <b>Authors: 
      </b>Robert S. Smith; Rigetti &amp; Co. Inc.; and contributors
    </p>
    <p>
      <b>Language Version: 
      </b>2021.1 (DRAFT)
    </p>
<nav class='toc-wrapper'>
  <h2>Table of Contents
  </h2>
  <ul>
<li>
  <a href='#1Preamble'>1. Preamble
  </a>
</li>
<li>
  <a href='#1-1An-Introduction-to-Quil'>1.1. An Introduction to Quil
  </a>
</li>
<li>
  <a href='#1-2Annexes'>1.2. Annexes
  </a>
</li>
<li>
  <a href='#2Operational-Semantic-Devices'>2. Operational Semantic Devices
  </a>
</li>
<li>
  <a href='#2-1Mathematical-Preliminaries'>2.1. Mathematical Preliminaries
  </a>
</li>
<li>
  <a href='#2-2The-Quantum-Abstract-Machine'>2.2. The Quantum Abstract Machine
  </a>
</li>
<li>
  <a href='#3Structure-of-a-Quil-Program'>3. Structure of a Quil Program
  </a>
</li>
<li>
  <a href='#3-1Meta-Syntax'>3.1. Meta-Syntax
  </a>
</li>
<li>
  <a href='#3-2Syntactic-Rudiments'>3.2. Syntactic Rudiments
  </a>
</li>
<li>
  <a href='#3-2-1Arithmetic-Expressions'>3.2.1. Arithmetic Expressions
  </a>
</li>
<li>
  <a href='#3-3Main-Program-Elements'>3.3. Main Program Elements
  </a>
</li>
<li>
  <a href='#3-4Comments'>3.4. Comments
  </a>
</li>
<li>
  <a href='#4Quantum-Gates'>4. Quantum Gates
  </a>
</li>
<li>
  <a href='#4-1Qubits-and-Quantum-State'>4.1. Qubits and Quantum State
  </a>
</li>
<li>
  <a href='#4-2Quantum-Gate-Definitions'>4.2. Quantum Gate Definitions
  </a>
</li>
<li>
  <a href='#4-2-1Structure-of-a-Gate-Definition'>4.2.1. Structure of a Gate Definition
  </a>
</li>
<li>
  <a href='#4-2-2Definition-by-Matrix'>4.2.2. Definition by Matrix
  </a>
</li>
<li>
  <a href='#4-2-3Definition-by-Permutation'>4.2.3. Definition by Permutation
  </a>
</li>
<li>
  <a href='#4-2-4Definition-by-Pauli-Sum'>4.2.4. Definition by Pauli Sum
  </a>
</li>
<li>
  <a href='#4-2-4-1Semantics'>4.2.4.1. Semantics
  </a>
</li>
<li>
  <a href='#4-2-4-2Example-Syntax'>4.2.4.2. Example Syntax
  </a>
</li>
<li>
  <a href='#4-2-4-3Example-Semantic-Reduction-of-CPHASE'>4.2.4.3. Example Semantic Reduction of CPHASE
  </a>
</li>
<li>
  <a href='#4-2-5Sequence-Gate-Definitions'>4.2.5. Sequence Gate Definitions
  </a>
</li>
<li>
  <a href='#4-2-5-1Semantics'>4.2.5.1. Semantics
  </a>
</li>
<li>
  <a href='#4-3Standard-Gate-Definitions'>4.3. Standard Gate Definitions
  </a>
</li>
<li>
  <a href='#4-3-1Pauli-Gates'>4.3.1. Pauli Gates
  </a>
</li>
<li>
  <a href='#4-3-2Hadamard-Gate'>4.3.2. Hadamard Gate
  </a>
</li>
<li>
  <a href='#4-3-3Phase-Gates'>4.3.3. Phase Gates
  </a>
</li>
<li>
  <a href='#4-3-4Controlled-Phase-Gates'>4.3.4. Controlled-Phase Gates
  </a>
</li>
<li>
  <a href='#4-3-5Cartesian-Rotation-Gates'>4.3.5. Cartesian Rotation Gates
  </a>
</li>
<li>
  <a href='#4-3-6Controlled-X-Gates'>4.3.6. Controlled-X Gates
  </a>
</li>
<li>
  <a href='#4-3-7Swap-Gates'>4.3.7. Swap Gates
  </a>
</li>
<li>
  <a href='#4-3-8Other-Gates'>4.3.8. Other Gates
  </a>
</li>
<li>
  <a href='#4-4Quantum-Gate-Applications'>4.4. Quantum Gate Applications
  </a>
</li>
<li>
  <a href='#4-4-1Syntax-and-Semantics'>4.4.1. Syntax and Semantics
  </a>
</li>
<li>
  <a href='#4-4-2DAGGER-Gate-Modifier'>4.4.2. DAGGER Gate Modifier
  </a>
</li>
<li>
  <a href='#4-4-3CONTROLLED-Gate-Modifier'>4.4.3. CONTROLLED Gate Modifier
  </a>
</li>
<li>
  <a href='#4-4-4FORKED-Gate-Modifier'>4.4.4. FORKED Gate Modifier
  </a>
</li>
<li>
  <a href='#4-4-5Chaining-Modifiers'>4.4.5. Chaining Modifiers
  </a>
</li>
<li>
  <a href='#5Quantum-State-Reset'>5. Quantum State Reset
  </a>
</li>
<li>
  <a href='#6Classical-Memory'>6. Classical Memory
  </a>
</li>
<li>
  <a href='#6-1Design-Considerations'>6.1. Design Considerations
  </a>
</li>
<li>
  <a href='#6-2Types'>6.2. Types
  </a>
</li>
<li>
  <a href='#6-3Declaring-Memory'>6.3. Declaring Memory
  </a>
</li>
<li>
  <a href='#6-3-1Declaring-Memory'>6.3.1. Declaring Memory
  </a>
</li>
<li>
  <a href='#6-3-2Declaring-Aliased-Memory'>6.3.2. Declaring Aliased Memory
  </a>
</li>
<li>
  <a href='#6-3-3Declaring-Aliased-Memory-Declaration-with-an-Offset'>6.3.3. Declaring Aliased Memory Declaration with an Offset
  </a>
</li>
<li>
  <a href='#6-3-4Portability-of-Aliased-Declarations'>6.3.4. Portability of Aliased Declarations
  </a>
</li>
<li>
  <a href='#6-3-5Duplicate-Declaration-Identifiers'>6.3.5. Duplicate Declaration Identifiers
  </a>
</li>
<li>
  <a href='#6-3-6Examples'>6.3.6. Examples
  </a>
</li>
<li>
  <a href='#6-3-6-1Register-Machine-with-a-Condition-Bit'>6.3.6.1. Register Machine with a Condition Bit
  </a>
</li>
<li>
  <a href='#6-3-6-2Memory-Mapped-RAM'>6.3.6.2. Memory-Mapped RAM
  </a>
</li>
<li>
  <a href='#6-3-6-3Computing-Bits-of-an-Angle'>6.3.6.3. Computing Bits of an Angle
  </a>
</li>
<li>
  <a href='#6-4Memory-Access-and-Dereferencing'>6.4. Memory Access and Dereferencing
  </a>
</li>
<li>
  <a href='#6-5Classical-Instructions'>6.5. Classical Instructions
  </a>
</li>
<li>
  <a href='#7Measurement'>7. Measurement
  </a>
</li>
<li>
  <a href='#8Classical-Control'>8. Classical Control
  </a>
</li>
<li>
  <a href='#8-1Halting-the-Program'>8.1. Halting the Program
  </a>
</li>
<li>
  <a href='#8-2Program-Labels-and-Branching'>8.2. Program Labels and Branching
  </a>
</li>
<li>
  <a href='#9Other-Instructions-and-Directives'>9. Other Instructions and Directives
  </a>
</li>
<li>
  <a href='#9-1No-Operation-Instruction'>9.1. No-Operation Instruction
  </a>
</li>
<li>
  <a href='#9-2Pragmas'>9.2. Pragmas
  </a>
</li>
<li>
  <a href='#9-3File-Inclusion'>9.3. File Inclusion
  </a>
</li>
<li>
  <a href='#10Circuits'>10. Circuits
  </a>
</li>
<li>
  <a href='#10-1Circuit-Syntax'>10.1. Circuit Syntax
  </a>
</li>
<li>
  <a href='#10-2Circuit-Expansion'>10.2. Circuit Expansion
  </a>
</li>
<li>
  <a href='#11History-and-Changes'>11. History and Changes
  </a>
</li>
<li>
  <a href='#11-1A-History-of-Quil'>11.1. A History of Quil
  </a>
</li>
<li>
  <a href='#11-2Changes'>11.2. Changes
  </a>
</li>
<li>
  <a href='#12Annex-T--Pulse-Level-Control'>12. Annex T: Pulse-Level Control
  </a>
</li>
<li>
  <a href='#12-1Frames'>12.1. Frames
  </a>
</li>
<li>
  <a href='#12-1-1DEFFRAME'>12.1.1. DEFFRAME
  </a>
</li>
<li>
  <a href='#12-1-1-1Frame-Attributes'>12.1.1.1. Frame Attributes
  </a>
</li>
<li>
  <a href='#12-2Waveforms'>12.2. Waveforms
  </a>
</li>
<li>
  <a href='#12-2-1Defining-new-waveforms'>12.2.1. Defining new waveforms
  </a>
</li>
<li>
  <a href='#12-3Pulses'>12.3. Pulses
  </a>
</li>
<li>
  <a href='#12-4Frame-Mutations'>12.4. Frame Mutations
  </a>
</li>
<li>
  <a href='#12-4-1Frequency'>12.4.1. Frequency
  </a>
</li>
<li>
  <a href='#12-4-2Phase'>12.4.2. Phase
  </a>
</li>
<li>
  <a href='#12-4-3Scale'>12.4.3. Scale
  </a>
</li>
<li>
  <a href='#12-5Capture'>12.5. Capture
  </a>
</li>
<li>
  <a href='#12-6Defining-Calibrations'>12.6. Defining Calibrations
  </a>
</li>
<li>
  <a href='#12-7Timing-and-Synchronization'>12.7. Timing and Synchronization
  </a>
</li>
  </ul>
</nav><p class='aside'><b>Note: </b>This document is in <em>DRAFT STATUS</em> and is for review
purposes only. It is being developed by the <a href='https://github.com/quil-lang/'>Quil-Lang group</a> on GitHub.</p><a name='1Preamble'><h2>1. Preamble</h2></a><a name='1-1An-Introduction-to-Quil'><h3>1.1. An Introduction to Quil</h3></a>
<p>This is the language specification for Quil, a language for hybrid
classical/quantum computations.
</p>
<p>Quil is an instruction-based language; each line of a Quil program
generally corresponds to a single, discrete action. Despite its
resemblance, Quil is <em>not</em> an assembly language.
</p><p class='aside'><b>Note: </b>An <em>assembly language</em> is a textual format for the machine
code of a specific computer architecture. Quil is not that, and may be
used for a variety of quantum computer architectures.</p>
<p>This is an example Quil program that simulates a coin flip:


<pre class='source-code'>DECLARE ro BIT[1]
H 0
MEASURE 0 ro[0]</pre>

Here, we can see the use of both classical data and quantum data. The
qubit numbered <tt>0</tt> is prepared in a uniform superposition by the
Hadamard gate <tt>H</tt>, and then measured in the computational basis,
depositing the resulting bit into a classic bit register named <tt>ro</tt>.
</p>
<p>The remainder of this document serves as a reference for all Quil
language syntax constructs and their associated semantics.
</p><a name='1-2Annexes'><h3>1.2. Annexes</h3></a>
<p>The Quil language is described throughout the ordinarily named sections of this document. There are additional sections, called <em>annexes</em>, which are optional extensions to the Quil language. These extensions may modify the syntax or semantics of the base specification in noted ways.
</p><a name='2Operational-Semantic-Devices'><h2>2. Operational Semantic Devices</h2></a><a name='2-1Mathematical-Preliminaries'><h3>2.1. Mathematical Preliminaries</h3></a>
<p>Define \(\mathscr{B}\) to be a Hilbert space isomorphic to
\(\mathbb{C}^2\). Some texts refer to this space as a <em>qubit</em>. We
may refer to it as a <em>qubit space</em>.
</p>
<p>We fix any orthonormal basis of \(V := \mathscr{B}^{\otimes n}\)
and call it the <em>computational basis</em>. We use uppercase letters
to refer to the vector space and the corresponding lowercase indexed
letters with an overbar to refer to the computational basis elements
(e.g., \(V\) for the vector space and \(\bar v_{*}\) for the basis
elements). We order the computational basis as \(\bar v_0\) to \(\bar
v_{2^n-1}\) so the \(k\)th bit of the index (i.e., the coefficient of
\(2^k\)) of \(\bar v_{*}\) corresponds to the \(0\)th or \(1\)st basis
of the \(k\)th factor of \(\mathscr{B}\) from the right. For example,
let \(n=3\), and let the left, middle, and right tensor factors of
\(\mathscr{B}\otimes\mathscr{B}\otimes\mathscr{B}\) be called \(R\),
\(S\), and \(T\) respectively. Consider the basis element \(\bar
v_4\). This index \(4\) is <tt>100</tt> in binary, and thus \(\bar v_4\)
corresponds to \(\bar r_1\otimes \bar s_0\otimes \bar t_0\).
</p><p class='aside'><b>Note: </b>Some texts might write \(v_4\) as either \(\vert 001\rangle\)
or \(\vert 100\rangle\). We prefer the latter if we are to use Dirac
notation.</p>
<p>Given \(V := \mathscr{B}\), we sometimes call \(\bar v_0\) the
<em>ground state</em> or <em>zero state</em>, and \(\bar v_1\) the
<em>excited state</em> or <em>one state</em>.
</p>
<p>Define \(\mathscr{U}(d)\) to be the <em>projective special
unitary group of dimension \(d\)</em>.
</p><p class='aside'><b>Note: </b>Note that many texts write &quot;PSU&quot; instead of &quot;U&quot;. We will often
say &quot;unitary&quot; when we really mean &quot;projective special unitary&quot;.</p><a name='2-2The-Quantum-Abstract-Machine'><h3>2.2. The Quantum Abstract Machine</h3></a>
<p>The semantics of Quil are defined operationally; that is, each
instruction of a Quil program is described by a change of some
state. This state is described by a mathematical object called the
&quot;quantum abstract machine&quot;.
</p>
<p>A <em>quantum abstract machine</em> or <em>QAM</em> is specified as:
<ul><li>A non-negative integer \(N\), representing the number of
    qubits available to the machine; and a non-negative integer \(M\),
    representing the number of bits available to the machine;</li><li>A pure quantum state (or <em>wavefunction</em>) \(\Psi\),
    which is a vector in Hilbert space \(\mathscr{B}^{\otimes N}\);</li><li>A classical state \(C\) of \(M\) ordered bits;</li><li>A set \(G\) of static quantum gates, each of which is an
    element of \(\mathscr{U}(2^N)\).</li><li>A set \(G'\) of parametric quantum gates, each of which is a
    \(k\)-ary function \(\mathbb{C}^k\to \mathscr{U}(2^N)\), where
    \(k\) can vary from gate to gate;</li><li>A program \(P\) consisting of an ordered list of Quil
    instructions; and</li><li>A program counter \(0 \le \kappa \le \vert P\vert\)
    represented as an integer indicating the &quot;current&quot; instruction.</li></ul>

This forms a \(6\)-tuple \((\Phi, C, G, G', P, \kappa)\). We may refer
to such a tuple as a QAM.
</p><a name='3Structure-of-a-Quil-Program'><h2>3. Structure of a Quil Program</h2></a><a name='3-1Meta-Syntax'><h3>3.1. Meta-Syntax</h3></a>
<p>In order to describe the syntax and semantics of a Quil program, we
use a syntax that is similar to <em>extended Backus-Naur form</em>,
though we deviate occasionally for convenience. While Quil&#039;s grammar
is context-free, specifying it is somewhat laborious due to the
possibility of identifiers being able to be used in some syntactic
constructs and other times not. As such, for syntactic constructs
which permit identifiers, we would need one set of productions, and
for those which don&#039;t, we would need another (nearly identical) set.
</p>
<p>In order to avoid this laborious repetition, we write productions
of the grammar to always include sometimes forbidden elements, and
instead specify in the surrounding text the context in which those
elements are or are not allowed.
</p><p class='aside'><b>Note: </b>When writing a recursive-descent parser, one would likely use
contextual flags to allow or disallow certain parsing rules, like
flags indicating the permission or lack thereof to use
identifiers. This leads to considerably shorter and clearer code.</p><a name='3-2Syntactic-Rudiments'><h3>3.2. Syntactic Rudiments</h3></a>
<p>Before proceeding to describe each component of a Quil program, it
will be useful to establish a few common pieces of syntax which will
be used later.
</p>
<p>The Quil language is represented as text. The text must be encoded
as UTF-8. The standard language constructs of Quil are all expressible
in the ASCII subset of UTF-8, but user programs may use codepoints
outside of UTF-8.
</p>
<p>Except when noted explicitly, whitespace has no significance and is
ignored. Tokens can be separated by arbitrary amounts and kinds of
whitespace.
</p>
<p>A newline is a single ASCII newline.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Newline</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-descriptive'>ASCII 10</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>A <em>terminator</em> is used to terminate most components of a Quil
program syntactically.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Terminator</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Newline</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> ;
</code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-descriptive'>End of File</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div>
<p>An <em>indent</em> is defined as exactly four spaces at the start of
a line. Indents in Quil programs can only happen following a newline.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Indent</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Newline</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-descriptive'>ASCII 32</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>4</sup></span></code></p></div>
<p>Note that since indents must follow a newline, we include the
newline as a part of the syntax definition of an indent.
</p>
<p>Non-negative integers are written as usual. Leading zeros do not
change the interpretation of these numeric literals.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Integer</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>[0-9]<span class='meta-syntax'><sup>+</sup></span></code></p></div>
<p>Real numbers are written in usual floating-point number syntax.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Real</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Integer</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>?</sup></span>.<span class='meta-syntax'><sup>?</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Integer</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span><span class='meta-syntax'>(</span>e <span class='meta-syntax'> | </span> E<span class='meta-syntax'>)</span><span class='meta-syntax'>(</span>- <span class='meta-syntax'> | </span> +<span class='meta-syntax'>)</span><span class='meta-syntax'><sup>?</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Integer</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>)</span><span class='meta-syntax'><sup>?</sup></span></code></p></div>
<p>Complex numbers are an extension of this.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Complex</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Integer</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Real</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Real</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>?</sup></span> i
  </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> pi</code></td></tr></table></div>
<p>Strings are characters bounded by double-quotation mark characters
&#039;<tt>&quot;</tt>&#039;. If a double-quotation mark should be used within the string,
it must be escaped with a backslash, like so: &#039;<tt>\&quot;</tt>&#039;. Similarly, if
a backslash should be used within a string, it must be escaped, like
so: &#039;<tt>\\</tt>&#039;.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>String</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>&quot;<span class='meta-syntax'>(</span>[^\&quot;] <span class='meta-syntax'> | </span> \&quot; <span class='meta-syntax'> | </span> \\<span class='meta-syntax'>)</span><span class='meta-syntax'><sup>*</sup></span>&quot;</code></p></div>
<p>Identifiers in Quil are alphanumeric Latin characters, along with
hyphens and underscores. Identifiers cannot start or end with a
hyphen &#039;<tt>-</tt>&#039;.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code>[A-Za-z_]
    </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> [A-Za-z_][A-Za-z0-9\-_]<span class='meta-syntax'><sup>*</sup></span>[A-Za-z0-9_]</code></td></tr></table></div>
<p>However, the following are <em>not</em> identifiers:


<pre class='source-code'>i pi</pre>
</p>
<p>The following identifiers are reserved (as Quil keywords):


<pre class='source-code'>ADD AND AS CONTROLLED CONVERT DAGGER DECLARE DEFCIRCUIT DEFGATE DIV EQ
EXCHANGE FORKED GE GT HALT INCLUDE IOR JUMP JUMP-UNLESS JUMP-WHEN
LABEL LE LOAD LT MATRIX MEASURE MOVE MUL NEG NOP NOT OFFSET PAULI-SUM
PERMUTATION PRAGMA RESET SHARING STORE SUB WAIT XOR</pre>
</p>
<p>The following identifiers are also reserved (for standard gate
definitions):


<pre class='source-code'>CAN CCNOT CNOT CPHASE CPHASE00 CPHASE01 CPHASE10 CSWAP CZ H I ISWAP
PHASE PISWAP PSWAP RX RY RZ S SWAP T X XY Y Z</pre>
</p>
<p>A <em>formal parameter</em> is an identifier prefixed with a percent
sign, with no whitespace in between.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameter</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>%<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>Multiple parameters may be separated by commas.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameters</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>(</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameter</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span>, <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameter</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>)</span><span class='meta-syntax'><sup>*</sup></span><span class='meta-syntax'>)</span><span class='meta-syntax'><sup>?</sup></span></code></p></div>
<p>A <em>formal argument</em> is simply an identifier.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Argument</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>Several formal arguments are separated by spaces, unlike
parameters.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Arguments</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Argument</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>+</sup></span></code></p></div><a name='3-2-1Arithmetic-Expressions'><h4>3.2.1. Arithmetic Expressions</h4></a>
<p>Frequently, various kinds of arithmetic expressions are needed. A
simple and not unusual grammar defines these arithmetic expressions.
</p>
<p>Depending on the specific grammatical context, arithmetic
expressions may or may not include references to formal parameters or
memory segments. Below, we define the grammar as including all of
these things, but certain contexts may disallow either or both of
them.
</p>
<p>Precedence of binary operators is defined in the following
order of descending tightness. Along with the operators are their
associativity directions.


<pre class='source-code'>^     RIGHT
* /   LEFT
+ -   LEFT</pre>
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> + <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> - <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> * <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> / <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> ^ <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Term</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Term</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code>- <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span> ( <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> )
    </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> ( <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> )
    </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Complex</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameter</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Memory Reference</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div>
<p>A <em>constant expression</em> is an arithmetic expression which does
not contain any parameters, memory references, or identifiers.
</p>
<p>We use comma-separated lists of arithmetic expressions frequently
enough to warrant their own production.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression List</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span>,
            <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>)</span><span class='meta-syntax'><sup>*</sup></span></code></p></div><a name='3-3Main-Program-Elements'><h3>3.3. Main Program Elements</h3></a>
<p>A Quil program consists of declarations, directives, and
instructions.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Program</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Program Element</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>*</sup></span></code></p></div><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Program Element</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Declaration</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Newline</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'> | </span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-descriptive'>End of File</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>)</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Directive</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Terminator</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Instruction</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Terminator</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div>
<p>A <em>declaration</em> typically specifies the existence of a named
object, like classical memory registers.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Declaration</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Gate Definition</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Circuit Definition</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Classical Memory Declaration</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div>
<p>A <em>directive</em> specifies information to software processing
Quil, such as the <tt>INCLUDE</tt> directive for including files.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Directive</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Pragma</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Label</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>File Include</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div>
<p>An <em>instruction</em> is an actual run-time executable effect.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Instruction</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Gate Application</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Measurement Instruction</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Circuit Application</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Classical Memory Instruction</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Reset Instruction</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Wait Instruction</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Branch Instruction</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>No-Operation Instruction</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Halt Instruction</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div><a name='3-4Comments'><h3>3.4. Comments</h3></a>
<p>Comments may exist syntactically, but do not change the semantics
of the program. Text including and following the &#039;<tt>#</tt>&#039; character are ignored up
to the end of the line.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Comment</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>#[^\n]<span class='meta-syntax'><sup>*</sup></span></code></p></div>
<p>There are no block comments.
</p><a name='4Quantum-Gates'><h2>4. Quantum Gates</h2></a><a name='4-1Qubits-and-Quantum-State'><h3>4.1. Qubits and Quantum State</h3></a>
<p>A Quil program manipulates quantum resources called <em>qubits</em>. Qubits are indexed by non-negative integers.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Qubit</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Integer</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>Qubit indexes have no significance on their own. Qubits must always
be referred to by their index. There is no bound on the number of
qubits in a Quil program, and any finite collection of qubits may
interact.
</p>
<p>Quil has no ways to allocate an unbounded or non-deterministic
number of qubits at run-time. The number of qubits used by a program
can always be statically determined.
</p>
<p>Sometimes, a qubit may instead have a formal argument in its
place. This may not be possible in all cases.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Formal Qubit</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Qubit</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Argument</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div><a name='4-2Quantum-Gate-Definitions'><h3>4.2. Quantum Gate Definitions</h3></a><a name='4-2-1Structure-of-a-Gate-Definition'><h4>4.2.1. Structure of a Gate Definition</h4></a>
<p>A gate definition allows us to name a unitary operation for
subsequent use in a program. A gate definition in general has the
following structure:
</p>
<pre class='source-code'>DEFGATE &lt;name&gt;(&lt;params&gt;) AS &lt;kind&gt;:
    &lt;body&gt;</pre>
<p>Here, the <tt>&lt;name&gt;</tt> names the gate, the <tt>&lt;kind&gt;</tt> states how we
are defining the gate, and the <tt>&lt;body&gt;</tt> depends on the <tt>kind</tt>. For
certain gates, <tt>&lt;params&gt;</tt> specifies parameters to the gate.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Gate Definition</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Matrix Gate Definition</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Permutation Gate Definition</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Pauli Sum Gate Definition</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Sequence Gate Definition</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div><a name='4-2-2Definition-by-Matrix'><h4>4.2.2. Definition by Matrix</h4></a>
<p>A gate can be defined by its matrix of complex numbers represented
in the computational basis with the aforementioned ordering.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Matrix Gate Definition</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>DEFGATE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span>(<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameters</span><span class='meta-syntax'>&#x27E9;</span>)<span class='meta-syntax'>)</span><span class='meta-syntax'><sup>?</sup></span><span class='meta-syntax'>(</span>AS MATRIX<span class='meta-syntax'>)</span><span class='meta-syntax'><sup>?</sup></span>:
<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Matrix Entries</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>A gate definitions with no parameters represents a static
gate. Otherwise it is a parametric gate.
</p>
<p>For readability, matrix entries are typically broken up into
lines.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Matrix Entries</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>(</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Indent</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Matrix Entry Line</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>)</span><span class='meta-syntax'><sup>+</sup></span></code></p></div>
<p>Each line contains a list of comma-separated arithmetic
expressions, most often simple integers or real numbers.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Matrix Entry Line</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span>, <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>)</span><span class='meta-syntax'><sup>*</sup></span></code></p></div>
<p>The arithmetic expressions may either be constant or refer to the
parameters of the defined gate.
</p><a name='4-2-3Definition-by-Permutation'><h4>4.2.3. Definition by Permutation</h4></a>
<p>A <em>permutation gate</em> is one that permutes the coefficients of
the wavefunction. A permutation \(p\) can be specified mathematically
as an ordering of the integers between \(0\) and \(n-1\) written out
as a list \[(p_1\;p_2\;\ldots\;p_n).\] Here, \(p\) is a map on
vectors such that if \(x\) is a column vector
\[(x_1,\ldots,x_n)^{\intercal}\] then \(p(x)\) is a column vector
\[(x_{p_1}, x_{p_2}, \ldots, x_{p_n})^{\intercal}.\] We specify
permutation gates exactly by these numbers.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Permutation Gate Definition</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>DEFGATE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span> AS PERMUTATION:<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Indent</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Permutation</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>Here, the permutation is a comma-separated list of non-negative
integers.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Permutation</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Integer</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span>,
        <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Integer</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>)</span><span class='meta-syntax'><sup>+</sup></span></code></p></div>
<p>There must be at least two integers specified, and the number of
integers specified must be a power-of-two.
</p><a name='4-2-4Definition-by-Pauli-Sum'><h4>4.2.4. Definition by Pauli Sum</h4></a>
<p>Quantum gates can be defined by an associated Hamiltonian, as in

\[U(\mathbf t) = \exp(-i \mathcal H(\mathbf t))\]

for a Hermitian operator \(\mathcal H\). Quil allows \(\mathcal H\) to
be specified as a <em>Pauli sum</em>, a sum of combinations of Pauli
operators.
</p>
<p>The syntax is as follows.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Pauli Sum Gate Definition</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>DEFGATE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span>(<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameters</span><span class='meta-syntax'>&#x27E9;</span>)<span class='meta-syntax'>)</span><span class='meta-syntax'><sup>?</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Arguments</span><span class='meta-syntax'>&#x27E9;</span>
AS PAULI-SUM:<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Pauli Terms</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>The collection of Pauli term must be written on their own lines.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Pauli Terms</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>(</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Indent</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Pauli Term</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>)</span><span class='meta-syntax'><sup>+</sup></span></code></p></div>
<p>Each Pauli term represents some coefficient multiplied against a
tensor product of Pauli operators.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Pauli Term</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Pauli Word</span><span class='meta-syntax'>&#x27E9;</span>(<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span>) <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Arguments</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>A <tt>PAULI-SUM</tt> gate definition is subject to some restrictions:

<ul><li>The number of <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Arguments</span><span class='meta-syntax'>&#x27E9;</span> must equal the length of the
    <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Pauli Word</span><span class='meta-syntax'>&#x27E9;</span>.</li><li>The <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> must be a real-valued expression which
    references only real numeric literals as well as parameters from
    the <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameters</span><span class='meta-syntax'>&#x27E9;</span> list of the gate definition.</li><li><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Arguments</span><span class='meta-syntax'>&#x27E9;</span> in a <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Pauli Term</span><span class='meta-syntax'>&#x27E9;</span> must only refer to
    arguments that exist in the gate definition.</li></ul>
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Pauli Word</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>(</span>I <span class='meta-syntax'> | </span> X <span class='meta-syntax'> | </span> Y <span class='meta-syntax'> | </span> Z<span class='meta-syntax'>)</span><span class='meta-syntax'><sup>+</sup></span></code></p></div><a name='4-2-4-1Semantics'><h4>4.2.4.1. Semantics</h4></a>
<p>We describe how one is intended to extract a matrix presentation of
an operator from such a Pauli sum, and then we remit the discussion of
semantics to that for <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Matrix Gate Definition</span><span class='meta-syntax'>&#x27E9;</span>.

<ol><li>Pad each Pauli word appearing in the sum with <tt>I</tt> letters,
    so that all formal qubits appear in all terms.</li><li>Sort the qubit arguments appearing in each term to agree
    with the qubit argument list in the definition
    header. Simultaneously, sort the letters appearing in the Pauli
    word to match.</li><li>Using the Quil-standard matrix definitions of <tt>I</tt>, <tt>X</tt>,
    <tt>Y</tt>, and <tt>Z</tt>, associate to each Pauli term&#039;s Pauli word the
    ordered tensor product of these basic matrices.</li><li>Scale each such matrix by the Pauli term&#039;s <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span>.</li><li>Sum the matrices, multiply by \(i=\sqrt{-1}\), and form the
   matrix exponential.</li></ol>
</p>
<p>See the next sections for an example semantic reduction.
</p><a name='4-2-4-2Example-Syntax'><h4>4.2.4.2. Example Syntax</h4></a>
<p>Many standard examples of gates admit short expression in these terms:


<pre class='source-code'>DEFGATE RY(%theta) q AS PAULI-SUM:
    Y(-%theta/2) q</pre>

This also includes many standard multi-qubit operators:


<pre class='source-code'>DEFGATE CPHASE(%theta) p q AS PAULI-SUM:
    ZZ(-%theta/4) p q
    Z(%theta/4) p
    Z(%theta/4) q

DEFGATE CAN(%alpha, %beta, %gamma) p q AS PAULI-SUM:
    XX(%alpha/4) p q
    YY(%beta/4)  p q
    ZZ(%gamma/4) p q</pre>

It also includes some operators encountered in practice, e.g., the following reduction of an Ansatz appearing in the electronic structure simulation problem for \(\mathrm H_2\):


<pre class='source-code'>DEFGATE UCC-H2(%theta) p q r s AS PAULI-SUM:
    YXXX(%theta) p q r s</pre>
</p><a name='4-2-4-3Example-Semantic-Reduction-of-CPHASE'><h4>4.2.4.3. Example Semantic Reduction of CPHASE</h4></a>
<p>In the example definition of <tt>CPHASE</tt> above, these steps proceed as follows:

<ol><li>We replace <tt>ZZ p q</tt> with <tt>ZZ p q</tt> (i.e., no change), <tt>Z p</tt>
    by <tt>ZI p q</tt>, and <tt>Z q</tt> by <tt>ZI q p</tt>, which each now apply
    to all the available formal qubits.</li><li>We replace <tt>ZZ p q</tt> by <tt>ZZ p q</tt> (i.e., no change), <tt>ZI
    p q</tt> by <tt>ZI p q</tt>, and <tt>ZI q p</tt> by <tt>IZ p q</tt>, which now all
    end in <tt>p q</tt>.</li><li>The tensor products associated to these three terms are respectively

      \[\begin{align*}
        ZZ &= \left( \begin{smallmatrix}1 \\ & -1 \\ & & -1 \\ & & & 1 \end{smallmatrix} \right) &
        ZI &= \left( \begin{smallmatrix}1 \\ & 1 \\ & & -1 \\ & & & -1 \end{smallmatrix} \right) &
        IZ &= \left( \begin{smallmatrix}1 \\ & -1 \\ & & 1 \\ & & & -1 \end{smallmatrix} \right),
      \end{align*}\]
      where we have elided zero entries.</li><li>After rescaling by the associated expressions, these matrices become

      \[\left( \begin{smallmatrix}-\theta/4 \\ & \theta/4 \\ & & \theta/4 \\ & & & -\theta/4 \end{smallmatrix} \right)
        \qquad
        \left( \begin{smallmatrix}\theta/4 \\ & \theta/4 \\ & & -\theta/4 \\ & & & -\theta/4 \end{smallmatrix} \right)
        \qquad
        \left( \begin{smallmatrix}\theta/4 \\ & -\theta/4 \\ & & \theta/4 \\ & & & -\theta/4 \end{smallmatrix} \right).\]</li><li>Taking the sum and multiplying by \(i\) yields

      \[\left( \begin{smallmatrix}i\theta/4 \\ & i\theta/4 \\ & & i\theta/4 \\ & & & -3i\theta/4 \end{smallmatrix} \right),\]

      and exponentiating yields

      \[\mathtt{CPHASE}(\theta) = \left( \begin{smallmatrix}e^{i\theta/4} \\ & e^{i\theta/4} \\ & & e^{i\theta/4} \\ & & & e^{-3i\theta/4} \end{smallmatrix} \right).\]</li></ol>

Up to global phase, this is evidently equivalent to the usual <tt>AS
MATRIX</tt> definition (as specified in the next section).
</p><a name='4-2-5Sequence-Gate-Definitions'><h4>4.2.5. Sequence Gate Definitions</h4></a>
<p>A gate can be defined by a sequence of other gate applications.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Sequence Gate Definition</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>DEFGATE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span>(<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameters</span><span class='meta-syntax'>&#x27E9;</span>)<span class='meta-syntax'>)</span><span class='meta-syntax'><sup>?</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Arguments</span><span class='meta-syntax'>&#x27E9;</span>
AS SEQUENCE:
<span class='meta-syntax'>(</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Indent</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Sequence Element</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>)</span><span class='meta-syntax'><sup>+</sup></span></code></p></div>
<p>A sequence element is effectively a gate application where the formal qubit must be an argument.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Sequence Element</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Modifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>*</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span>(
                <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression List</span><span class='meta-syntax'>&#x27E9;</span>
            )<span class='meta-syntax'>)</span><span class='meta-syntax'><sup>?</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Argument</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>+</sup></span></code></p></div><a name='4-2-5-1Semantics'><h4>4.2.5.1. Semantics</h4></a>
<p>Each argument of a <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Sequence Element</span><span class='meta-syntax'>&#x27E9;</span> must correspond to an <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Argument</span><span class='meta-syntax'>&#x27E9;</span> contained in <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Arguments</span><span class='meta-syntax'>&#x27E9;</span> found in the gate definition header (An <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Argument</span><span class='meta-syntax'>&#x27E9;</span> is not a <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Qubit</span><span class='meta-syntax'>&#x27E9;</span>). An <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> in the <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression List</span><span class='meta-syntax'>&#x27E9;</span> may reference a <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameter</span><span class='meta-syntax'>&#x27E9;</span> from <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameters</span><span class='meta-syntax'>&#x27E9;</span> found in the gate definition header, but this is not required (an explicitly defining some angle of rotation is also possible, for example).
</p>
<p>The unitary for a sequence gate should be the result of multiplying each unitary from that gate&#039;s sequence elements in the order they appear in the body. All the resulting unitary should cover the combined space of the arguments for that gate definition (even unused arguments).
</p><a name='4-3Standard-Gate-Definitions'><h3>4.3. Standard Gate Definitions</h3></a><a name='4-3-1Pauli-Gates'><h4>4.3.1. Pauli Gates</h4></a>\[\begin{align*}
\texttt{I} &= \left(\begin{smallmatrix}
1 & 0\\
0 & 1
\end{smallmatrix}\right)
&
\texttt{X} &= \left(\begin{smallmatrix}
0 & 1\\
1 & 0
\end{smallmatrix}\right)
&
\texttt{Y} &= \left(\begin{smallmatrix}
0 & -i\\
i & 0
\end{smallmatrix}\right)
&
\texttt{Z} &= \left(\begin{smallmatrix}
1 & 0\\
0 & -1
\end{smallmatrix}\right)
\end{align*}\]<a name='4-3-2Hadamard-Gate'><h4>4.3.2. Hadamard Gate</h4></a>\[\texttt{H} = \tfrac{1}{\sqrt{2}}\left(\begin{smallmatrix}
1 & 1\\
1 & -1
\end{smallmatrix}\right)\]<a name='4-3-3Phase-Gates'><h4>4.3.3. Phase Gates</h4></a>\[\begin{align*}
\texttt{PHASE}(\theta) &= \left(\begin{smallmatrix}
1 & 0\\
0 & e^{i\theta}
\end{smallmatrix}\right)
&
\texttt{S} &= \texttt{PHASE}(\pi/2)
&
\texttt{T} &= \texttt{PHASE}(\pi/4)
\end{align*}\]<a name='4-3-4Controlled-Phase-Gates'><h4>4.3.4. Controlled-Phase Gates</h4></a>\[\begin{align*}
\texttt{CPHASE00}(\theta) &= \operatorname{diag}(e^{i\theta},1,1,1) \\
\texttt{CPHASE01}(\theta) &= \operatorname{diag}(1,e^{i\theta},1,1) \\
\texttt{CPHASE10}(\theta) &= \operatorname{diag}(1,1,e^{i\theta},1) \\
\texttt{CPHASE}(\theta) &= \operatorname{diag}(1,1,1,e^{i\theta}) \\
\texttt{CZ} &= \texttt{CPHASE}(\pi)
\end{align*}\]
<p>Note that one has the following equivalences in Quil:


<pre class='source-code'>CZ == CONTROLLED Z
CPHASE = CONTROLLED PHASE</pre>
</p><a name='4-3-5Cartesian-Rotation-Gates'><h4>4.3.5. Cartesian Rotation Gates</h4></a>\[\begin{align*}
\texttt{RX}(\theta) &= \left(\begin{smallmatrix}
\cos\frac{\theta}{2} & -i\sin\frac{\theta}{2}\\
-i\sin\frac{\theta}{2} & \cos\frac{\theta}{2}
\end{smallmatrix}\right)\\
\texttt{RY}(\theta) &= \left(\begin{smallmatrix}
\cos\frac{\theta}{2} & -\sin\frac{\theta}{2}\\
\sin\frac{\theta}{2} & \cos\frac{\theta}{2}
\end{smallmatrix}\right)\\
\texttt{RZ}(\theta) &= \left(\begin{smallmatrix}
e^{-i\theta/2} & 0\\
0 & e^{i\theta/2}
\end{smallmatrix}\right)
\end{align*}\]<a name='4-3-6Controlled-X-Gates'><h4>4.3.6. Controlled-X Gates</h4></a>\[\begin{align*}
\texttt{CNOT} &=
\left(
\begin{smallmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 1\\
0 & 0 & 1 & 0
\end{smallmatrix}
\right) &
\texttt{CCNOT} &=
\left(
\begin{smallmatrix}
    1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
    0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
    0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
    0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
    0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
    0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
    0 & 0 & 0 & 0 & 0 & 0 & 1 & 0
\end{smallmatrix}
\right)
\end{align*}\]<p class='aside'><b>Note: </b>The gate <tt>CCNOT</tt> is sometimes known as the <em>Toffoli
gate</em>. It is a universal classical logic gate.</p>
<p>Note that one has the following equivalences in Quil:


<pre class='source-code'>CNOT  == CONTROLLED X
CCNOT == CONTROLLED CONTROLLED X</pre>
</p><a name='4-3-7Swap-Gates'><h4>4.3.7. Swap Gates</h4></a>\[\begin{align*}
\texttt{PSWAP}(\theta) &=
\left(
\begin{smallmatrix}
1 & 0 & 0 & 0\\
0 & 0 & e^{i\theta} & 0\\
0 & e^{i\theta} & 0 & 0\\
0 & 0 & 0 & 1
\end{smallmatrix}
\right)\\
\texttt{SWAP} &= \texttt{PSWAP}(0)\\
\texttt{ISWAP} &= \texttt{PSWAP}(\pi/2)\\
\texttt{PISWAP}(\theta) &=
\left(
\begin{smallmatrix}
1 & 0 & 0 & 0\\
0 & \cos(\theta/2) & i\sin(\theta/2) & 0\\
0 & i\sin(\theta/2) & \cos(\theta/2) & 0\\
0 & 0 & 0 & 1
\end{smallmatrix}
\right)\\
\texttt{CSWAP} &=
\left(
\begin{smallmatrix}
    1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
    0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
    0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
    0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
    0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
    0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
    0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 1
\end{smallmatrix}
\right)
\end{align*}\]<p class='aside'><b>Note: </b>The gate <tt>CSWAP</tt> is sometimes known as the <em>Fredkin
gate</em>. It is a universal classical logic gate.</p>
<p>Note that one has the following equivalence in Quil:


<pre class='source-code'>CSWAP == CONTROLLED SWAP</pre>
</p><a name='4-3-8Other-Gates'><h4>4.3.8. Other Gates</h4></a>\[\begin{align*}
\texttt{XY}(\theta) &= \exp\left( -i\theta(\texttt{X}^{\otimes 2} + \texttt{Y}^{\otimes 2}) \right)
                     = \texttt{PISWAP}(\theta)\\
\texttt{CAN}(\alpha, \beta, \gamma) &=
\exp\left( -i (  \alpha\texttt{X}^{\otimes 2}
               + \beta\texttt{Y}^{\otimes 2}
               + \gamma\texttt{Z}^{\otimes 2}
    \right)
\end{align*}\]<p class='aside'><b>Note: </b>Every two-qubit gate can be written in terms of <tt>CAN</tt>,
possibly with up to two preceding and two proceeding arbitrary
one-qubit gates.</p>
<p>The definition of <tt>CAN</tt> can be written as the following Quil
matrix definition:


<pre class='source-code'>DEFGATE CAN(%alpha, %beta, %gamma):
    (cis((%alpha+%beta-%gamma)/2)+cis((%alpha-%beta+%gamma)/2))/2, 0, 0, (cis((%alpha-%beta+%gamma)/2)-cis((%alpha+%beta-%gamma)/2))/2
    0, (cis((%alpha+%beta+%gamma)/(-2))+cis((%beta+%gamma-%alpha)/2))/2, (cis((%alpha+%beta+%gamma)/(-2))-cis((%beta+%gamma-%alpha)/2))/2, 0
    0, (cis((%alpha+%beta+%gamma)/(-2))-cis((%beta+%gamma-%alpha)/2))/2, (cis((%alpha+%beta+%gamma)/(-2))+cis((%beta+%gamma-%alpha)/2))/2, 0
    (cis((%alpha-%beta+%gamma)/2)-cis((%alpha+%beta-%gamma)/2))/2, 0, 0, (cis((%alpha+%beta-%gamma)/2)+cis((%alpha-%beta+%gamma)/2))/2</pre>

It also has a straightforward definition as a <tt>PAULI-SUM</tt>.
</p><a name='4-4Quantum-Gate-Applications'><h3>4.4. Quantum Gate Applications</h3></a><a name='4-4-1Syntax-and-Semantics'><h4>4.4.1. Syntax and Semantics</h4></a>
<p>A gate is applied via the following syntax.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Gate Application</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Modifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>*</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span>(
                <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression List</span><span class='meta-syntax'>&#x27E9;</span>
            )<span class='meta-syntax'>)</span><span class='meta-syntax'><sup>?</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Formal Qubit</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>+</sup></span></code></p></div>
<p>We refer to Section II.A of <a href='https://arxiv.org/abs/1608.03355'><em>A Practical Quantum
Instruction Set Architecture</em></a> for extensive and detailed mathematical
discussion on the semantics of gate application realized as a matrix
operator on the Hilbert space of the QAM.
</p>
<p>Quil supports three kinds of unitary modifiers.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Modifier</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code>DAGGER
    </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> CONTROLLED
    </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> FORKED(<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression List</span><span class='meta-syntax'>&#x27E9;</span>)</code></td></tr></table></div>
<p>These are described in the next sections.
</p><a name='4-4-2DAGGER-Gate-Modifier'><h4>4.4.2. DAGGER Gate Modifier</h4></a>
<p>The <tt>DAGGER</tt> modifier represents the adjoint operation or
complex-conjugate transpose. Since every gate is a unitary operator,
this is just the inverse. For example, if <tt>G</tt> is a gate described by
the one-qubit operator

\[\begin{pmatrix}
a & b\\
c & d
\end{pmatrix}\]

then <tt>DAGGER G</tt> is

\[\begin{pmatrix}
a^* & c^*\\
b^* & d^*
\end{pmatrix}\]

where \(z^*\) is the complex-conjugate of \(z\).
</p>
<p>Because <tt>DAGGER</tt> is the inverse, the sequence of Quil
instructions


<pre class='source-code'>G q1 ... qn
DAGGER G q1 ... qn</pre>

acts as an identity gate. As another example, consider the gate
<tt>PHASE</tt>, which is defined as


<pre class='source-code'>DEFGATE PHASE(%alpha):
    1, 0
    0, cis(%alpha)</pre>

where
\[\operatorname{cis}\alpha := \cos\alpha + i \sin\alpha = e^{i\alpha}.\]
Then


<pre class='source-code'>DAGGER PHASE(t) q</pre>

is equivalent to


<pre class='source-code'>PHASE(-t) q</pre>

for all \(\mathtt{t}\in\mathbb{R}\).
</p><a name='4-4-3CONTROLLED-Gate-Modifier'><h4>4.4.3. CONTROLLED Gate Modifier</h4></a>
<p>The <tt>CONTROLLED</tt> modifier takes some gate <tt>G</tt> acting on some
number of qubits <tt>q1</tt> to <tt>qn</tt> and makes it conditioned on the
state of some new qubit <tt>c</tt>. In terms of the matrix representation,
if <tt>c</tt> is in the one-state, then <tt>G</tt> is applied to the remaining
qubits; and if <tt>c</tt> is in the zero-state, no operation is
applied. Therefore, an application of the \(n\)-qubit operator <tt>G</tt>
as in


<pre class='source-code'>G q1 ... qn</pre>

has the controlled variant with <tt>CONTROLLED G</tt> an (n+1)-qubit
operator:


<pre class='source-code'>CONTROLLED G c q1 ... qn</pre>
</p>
<p>For example, the gate <tt>CONTROLLED X 1 0</tt> is the familiar
controlled-not gate, which can also be written using the standard
built-in Quil gate <tt>CNOT 1 0</tt>.
</p>
<p>Specifically, when acting on a gate <tt>G</tt> that can be represented
as an \(N \times N\) matrix \(U\), <tt>CONTROLLED G</tt> produces a gate
<tt>G&#039;</tt> described by the \(2N \times 2N\) matrix \(C(U)\) such that
\(C(U) := I \oplus U\), where \(I\) is the \(N \times N\) identity
matrix and \(\oplus\) is a direct sum. For example, if \(U\) is the
one-qubit operator

\[\begin{pmatrix}
a & b \\
c & d
\end{pmatrix}\]

then \(C(U)\) is

\[\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & a & b \\
0 & 0 & c & d \\
\end{pmatrix}.\]
</p><a name='4-4-4FORKED-Gate-Modifier'><h4>4.4.4. FORKED Gate Modifier</h4></a>
<p>Let <tt>G</tt> be a parametric gate of \(k\) parameters <tt>r1</tt> to <tt>rk</tt>
and \(n\) qubits <tt>q1</tt> to <tt>qn</tt>. This is written:


<pre class='source-code'>G(r1, ..., rk) q1 ... qn</pre>

Next, consider a second set of \(k\) parameters <tt>s1</tt> to <tt>sk</tt>. The
<tt>FORKED</tt> modifier takes such a gate <tt>G</tt> and allows either set of
parameters to be used conditioned on an additional qubit <tt>c</tt>.


<pre class='source-code'>FORKED G(r1, ..., rk, s1, ..., sk) c q1 ... qn</pre>

Roughly speaking, in terms of the matrix representation of the
operator, this is equivalent to the pseudocode:


<pre class='source-code'>if c = 0:
    G(r1, ..., rk) q1 ... qn
else if c = 1:
    G(s1, ..., sk) q1 ... qn</pre>
</p><p class='aside'><b>Note: </b>It is <em>very</em> important to note that both <tt>CONTROLLED</tt>
and <tt>FORKED</tt> are purely quantum, unitary operations. There is no
&quot;actual&quot; conditional branching. The use of the above pseudocode is to
illustrate how one might write the matrix representation in the
standard computational basis.</p>
<p>For example, the built-in gate <tt>RX</tt> takes a single <tt>%theta</tt>
parameter and acts on a single qubit, like so <tt>RX(pi/2)
0</tt>. Therefore, <tt>FORKED RX(pi/2, pi/4) 1 0</tt> produces a &quot;forked&quot;
version of <tt>RX</tt>, conditioned on qubit <tt>1</tt>. If qubit <tt>1</tt> is in
the zero-state, this corresponds to <tt>RX(pi/2) 0</tt> and to <tt>RX(pi/4)
0</tt> if qubit <tt>1</tt> is in the one-state.
</p>
<p>In general, when acting on a parametric gate <tt>G</tt> of \(k\)
parameters that can be represented as an \(N \times N\) matrix

\[U(p_1,\ldots,p_k),\]<tt>FORKED G</tt> produces a \(2N \times 2N\) matrix

\[F(U)(p_1,\ldots,p_k,p_{k+1},\ldots,p_{2k})
:=
U(p_1,\ldots,p_k) \oplus U(p_{k+1},\ldots,p_{2k}),\]

where \(\oplus\) is the direct sum.
</p>
<p>For example, the gate <tt>RZ</tt> is defined as


<pre class='source-code'>DEFGATE RZ(%theta):
    cis(-%theta/2), 0
    0,              cis(%theta/2)</pre>

Therefore, <tt>FORKED RZ(\(\theta_0\), \(\theta_1\)) 1 0</tt>, for real
numbers \(\theta_0\) and \(\theta_1\) results in a two-qubit operator
that can be described by the matrix

\[\begin{pmatrix}
\operatorname{cis}(-\theta_0/2) & 0         & 0          & 0         \\
0          & \operatorname{cis}(\theta_0/2) & 0          & 0         \\
0          & 0         & \operatorname{cis}(-\theta_1/2) & 0         \\
0          & 0         & 0          & \operatorname{cis}(\theta_1/2) \\
\end{pmatrix}.\]
</p><a name='4-4-5Chaining-Modifiers'><h4>4.4.5. Chaining Modifiers</h4></a>
<p>When gate modifiers are chained, they consume qubits left-to-right,
so that in the following example, the <tt>CONTROLLED</tt> modifier is
conditioned on qubit <tt>0</tt>, <tt>FORKED</tt> on qubit <tt>1</tt>, and the gate
<tt>G</tt> acts on qubit <tt>2</tt>.


<pre class='source-code'>CONTROLLED FORKED DAGGER G 0 1 2
    |         |          | ^ ^ ^
    |         |          | | | |
    |         |          +-|-|-+
    |         +------------|-+
    +----------------------+</pre>
</p>
<p>Note that chaining multiple <tt>FORKED</tt> modifiers causes the
numbers of parameters consumed by the gate to double for each
additional <tt>FORKED</tt>. For example:


<pre class='source-code'>RX(pi) 0
FORKED RX(pi, pi/2) 1 0
FORKED FORKED RX(pi, pi/2, pi/4, pi/8) 2 1 0</pre>

You can think of that last example as representing the following
decision tree, where an edge label like <tt>q2=0</tt> means that qubit
<tt>2</tt> is in the zero state.


<pre class='source-code'>+----------------------------------------------------------------------------+
|            FORKED FORKED RX(pi, pi/2, pi/4, pi/8) 2 1 0                    |
|                    /                               \                       |
|                 q2=0                              q2=1                     |
|                  /                                   \                     |
|     FORKED RX(pi, pi/2) 1 0                  FORKED RX(pi/4, pi/8) 1 0     |
|        /              \                         /               \          |
|     q1=0             q1=1                    q1=0              q1=1        |
|      /                  \                     /                   \        |
| RX(pi) 0              RX(pi/2) 0        RX(pi/4) 0              RX(pi/8) 0 |
+----------------------------------------------------------------------------+</pre>
</p><a name='5Quantum-State-Reset'><h2>5. Quantum State Reset</h2></a>
<p>The quantum state may be reset to \(\bar \psi_0\) (i.e., all qubits
in the ground state) by issuing a reset instruction.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>State Reset Instruction</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>RESET</code></p></div>
<p>Instead, one may reset an individual qubit.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Qubit Reset Instruction</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>RESET <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Formal Qubit</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>This has the semantics corresponding to the following pseudo-code:
</p>
<pre class='source-code'>if 1 == MEASURE(qubit) then X(qubit)</pre>
<p>These make up the ways the quantum state may be reset.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Reset Instruction</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>State Reset Instruction</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Qubit Reset Instruction</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div><a name='6Classical-Memory'><h2>6. Classical Memory</h2></a>
<p>This section explains Quil&#039;s classical memory model.
</p><a name='6-1Design-Considerations'><h3>6.1. Design Considerations</h3></a><em>This section is descriptive and not normative.</em>
<p>In assembly code, in general, types are considered only at the
mnemonic or interpretation level. They&#039;re not often a consideration in
the code itself. (Though this is not always true, machine codes for
dynamic languages included the notion of type checking and type tags
at the instruction level.) On modern processor architectures, one has
a large <em>random access memory</em> (RAM) which is byte-addressable,
and a series of processor <em>registers</em> that hold usually one
word&#039;s worth of data. (A <em>word</em> is often some multiple of bytes,
usually 4 or 8.) A <em>register machine</em> is one that loads values
from memory to the registers, does some operation, and often stores
the results back into memory.
</p>
<p>So far, we&#039;ve spoken only of bytes or multiples thereof. A byte&#x2014;or
word for that matter&#x2014;is simply a measure of a number of bits, with no
additional attached interpretation. What gives a byte interpretation
is the literal machinery attached to the registers in which the bytes
are stored. Implicit in the machinery, usually electrical circuitry,
is a way of transforming bytes into a new ones. This machinery is
invoked with an <em>opcode</em>. Since opcodes relate to physical machinery,
opcodes are often only pertinent to a subset of registers that a
machine has. From here, we get a usual partitioning of registers:
registers that deal with general integer arithmetic, registers that
deal with floating point numbers, registers that deal with vectorized
low-precision arithmetic, registers that interact with main memory,
and so on. The partition isn&#039;t always so strict; <em>general purpose
registers</em> often are capable of many disparate operations.
</p>
<p>RAM more often than not lacks any serious kind of operation except
loading and storing. Similarly, cross-register opcodes also deal with
the movement of data and not operation on the data contained
within. When we want to do something like adding an integer and
floating point number, we have to put the integer into a floating
point representation, move it from an integer register to a floating
point register, and perform the addition across two floating point
registers. Some architectures, such as the x87 floating point unit,
can perform the representation-changing and loading in a single
instruction (e.g., the <tt>FILD</tt> instruction).
</p>
<p>Quil was designed to be an instruction language that doesn&#039;t
conform to any physical architecture. It was designed to accommodate
evolving quantum architectures in terms of their memory models and
their native gates. In some sense, Quil can be seen as a portable
bytecode of sorts, (currently) without an actual byte-code
representation.
</p>
<p>The original 2016 Quil paper assumes there is an unbounded classical
memory composed of a series of bits, and segments of these bits can be
interpreted as a real or complex number. While very simplistic, it has
a few flaws:

<ul><li>The type of a data segment is determined solely by its
    length (64 bits indicates a double-precision floating point
    number, 128 bits indicates a double-precision complex number).</li><li>There are no provisions for the construction or use of
    integer data, which is desirable for counters and frequentist
    statistics.</li><li>There are no classical instructions that make use of
    segments, despite an inherent desire to do high-speed arithmetic
    on gate angles.</li><li>Quil code making heavy use of segments quickly becomes
    unwieldy and unreadable.</li><li>Quil code has no friendly notion of <em>linkage</em>, which
    would allow a concurrently run classical program to refer to named
    data.</li></ul>
</p>
<p>In the remainder of this section, we describe a replacement for the
notion of classical data in Quil. It is similar to C in that we don&#039;t
select any particular memory model, and require the user to specify
what he or she requires in terms of layout. Similarly departing from
usual instruction sets, we allow for memory to be interpreted through
multiple type lenses. In C, we accomplish this by casting pointers and
dereferencing. Since we don&#039;t have a notion of pointers, we accomplish
this with explicit declaration and aliasing.
</p>
<p>With Quil&#039;s classical memory model, we can write code which does
the following:


<pre class='source-code'>DECLARE count INTEGER
DECLARE stats INTEGER
DECLARE measurement INTEGER
DECLARE angle REAL
DECLARE cond BIT

# Initialize
MOVE stats 0
MOVE angle 0.0

# Start the angle loop
LABEL @start_angle_loop
LT cond angle 6.283185307179586
JUMP-UNLESS @end cond
# Perform histogram loop, 1000 shots
MOVE count 1000
LABEL @stats_loop
RX(angle) 0
MEASURE 0 measurement
ADD stats measurement
SUB count 1
GT cond count 0
JUMP-WHEN @stats_loop cond
# Calculate next angle
ADD angle 0.3926990816987241   # pi/8
JUMP @start_angle_loop
LABEL @end</pre>
</p>
<p>This will be roughly equivalent to the following C program:


<pre class='source-code'>int count, stats, measurement;
float angle;
stats = 0;
for(angle = 0.0; angle &lt; 6.283185307179586; angle += 0.3926990816987241) {
    for(count = 1000; count &gt; 0; count--) {
        RX(angle) 0
        measurement = MEASURE 0
        stats += measurement
    }
}</pre>
</p><a name='6-2Types'><h3>6.2. Types</h3></a>
<p>The supported types are <tt>BIT</tt> which represents one bit, <tt>OCTET</tt>
which represents 8 bits, <tt>INTEGER</tt> which represents a machine-sized
signed integer, and <tt>REAL</tt> which represents a machine-sized real
number. The formats/layouts of these are specific to the machine being
run on.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Base Type</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code>BIT
   </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> OCTET
   </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> INTEGER
   </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> REAL</code></td></tr></table></div>
<p>When we speak of <em>size</em>, we mean the number of octets that a
type represents. The notion of <em>size</em> is distinct from
<em>length</em>, which instead refers to some count of elements of a
particular type.
</p>
<p>A fixed-length vector of a type is denoted by the type name
followed by an integer in brackets. For instance, <tt>REAL[5]</tt> is a
type that represents five real numbers in sequence. The type
<tt>INTEGER</tt> is guaranteed to be large enough to hold a valid length of
octets, and is guaranteed to hold at least the values \(-127\) to
\(128\).
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Type</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Base Type</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Base Type</span><span class='meta-syntax'>&#x27E9;</span>[<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Integer</span><span class='meta-syntax'>&#x27E9;</span>]</code></td></tr></table></div>
<p>There are currently no provisions for adding additional types.
</p><a name='6-3Declaring-Memory'><h3>6.3. Declaring Memory</h3></a>
<p>Quil doesn&#039;t have a notion of <em>allocating</em> memory, but rather
the notion of <em>declaring the existence</em> of memory. In the
following, we introduce the <tt>DECLARE</tt> directive, which describes
available memory for a program to use.
</p>
<p>Some quantum computing architectures might restrict what can be
declared, what types can be used, what names can be used, etc. It is
recommended to be as liberal as possible in what can be declared,
while remaining true to the architectural constraints of the system on
which Quil is executed.
</p>
<p>The <tt>DECLARE</tt> directive is used to declare a vector of typed
memory. There are three variants: plain declaration, aliased
declaration, and aliased declaration with offset.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Classical Memory Declaration</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Plain Memory Declaration</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Aliased Memory Declaration</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Offset Memory Declaration</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div><a name='6-3-1Declaring-Memory'><h4>6.3.1. Declaring Memory</h4></a>
<p>The simplest kind of memory declaration is a plain one.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Plain Memory Declaration</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>DECLARE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Type</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>This declares that <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span> designates memory which can hold
<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Type</span><span class='meta-syntax'>&#x27E9;</span>. If <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Type</span><span class='meta-syntax'>&#x27E9;</span> is a scalar type, then it is assumed to
designate a vector of length 1. That is, the following two lines are
equivalent:


<pre class='source-code'>DECLARE x INTEGER
DECLARE x INTEGER[1]</pre>
</p>
<p>In the program that would follow either of these declarations,
<tt>x</tt> or equivalently <tt>x[0]</tt> will refer to an integer quantity.
</p><a name='6-3-2Declaring-Aliased-Memory'><h4>6.3.2. Declaring Aliased Memory</h4></a><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Aliased Memory Declaration</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>DECLARE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>1</span></sub><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Type</span><span class='meta-syntax'>&#x27E9;</span> SHARING <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>2</span></sub><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>This declares that <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>1</span></sub><span class='meta-syntax'>&#x27E9;</span> designates memory which can hold
<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Type</span><span class='meta-syntax'>&#x27E9;</span>, but <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>1</span></sub><span class='meta-syntax'>&#x27E9;</span> shares memory with that which is designated
by <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>2</span></sub><span class='meta-syntax'>&#x27E9;</span>. Here, the total memory size pointed to by
<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>1</span></sub><span class='meta-syntax'>&#x27E9;</span> shall not exceed the total memory size pointed to by
<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>2</span></sub><span class='meta-syntax'>&#x27E9;</span>.
</p>
<p>An implementation is free to reject programs where particular
instances of sharing is invalid (e.g., alignment is violated;
disparate memories are unshareable; etc.).
</p><a name='6-3-3Declaring-Aliased-Memory-Declaration-with-an-Offset'><h4>6.3.3. Declaring Aliased Memory Declaration with an Offset</h4></a><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Offset Memory Declaration</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>DECLARE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>1</span></sub><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Type</span><span class='meta-syntax'>&#x27E9;</span>
        SHARING <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>2</span></sub><span class='meta-syntax'>&#x27E9;</span>
        OFFSET
        <span class='meta-syntax'>(</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Integer</span><sub><span class='meta-syntax-identifier'>i</span></sub><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Type</span><sub><span class='meta-syntax-identifier'>i</span></sub><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>)</span><span class='meta-syntax'><sup>+</sup></span></code></p></div>
<p>This is similar to the aliased declaration, but it allows
<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>1</span></sub><span class='meta-syntax'>&#x27E9;</span> to designate memory in the middle of that which is
designated by <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>2</span></sub><span class='meta-syntax'>&#x27E9;</span>. In particular, <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>1</span></sub><span class='meta-syntax'>&#x27E9;</span> will point
to memory a total of \[\sum_i \langle\texttt{Integer}_i\rangle\cdot
\text{sizeof}(\langle\texttt{Type}_i\rangle)\] bits after the start of
<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>2</span></sub><span class='meta-syntax'>&#x27E9;</span>. As with an aliased declaration, the memory at
<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>1</span></sub><span class='meta-syntax'>&#x27E9;</span> must not overflow the end of <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><sub><span class='meta-syntax-identifier'>2</span></sub><span class='meta-syntax'>&#x27E9;</span>.
</p>
<p>Implementations may enforce alignment by way of erroring if the
stated declaration is invalid. Implementations must <em>not</em> round
up or down to alignment boundaries.
</p><a name='6-3-4Portability-of-Aliased-Declarations'><h4>6.3.4. Portability of Aliased Declarations</h4></a>
<p>Aliased declarations with mixed types require an intimate view of
the target architecture. The widths of each data type, which are
hitherto unspecified, must be known. For example, the following
declarations may not be valid of the size of <tt>REAL</tt> exceeds the size
of <tt>INTEGER</tt>.


<pre class='source-code'>DECLARE x INTEGER
DECLARE y REAL SHARING x</pre>

Even if such a declaration is valid, operations on <tt>y</tt> are not
portably specified. For example, continuing the above,


<pre class='source-code'>DECLARE b BIT
MOVE x 0
EQ b y 0.0</pre>

could result in any value for <tt>b</tt>, depending on the implementation.
</p>
<p>An implementation shall describe the bit-level description of the
types, the available declarable memories, the limits on the declared
memory, alignment requirements, and limits on sharing and offsets.
</p><a name='6-3-5Duplicate-Declaration-Identifiers'><h4>6.3.5. Duplicate Declaration Identifiers</h4></a>
<p>It is an error to declare the same name more than once.
</p><a name='6-3-6Examples'><h4>6.3.6. Examples</h4></a><a name='6-3-6-1Register-Machine-with-a-Condition-Bit'><h4>6.3.6.1. Register Machine with a Condition Bit</h4></a>
<p>Here we consider a layout for a machine that has one integer
register, two real registers, and a <em>condition bit</em> used for
doing comparisons and branching.


<pre class='source-code'>DECLARE f1 REAL
DECLARE f2 REAL
DECLARE x INTEGER
DECLARE cmp BIT    # cmp for &quot;comparison&quot;</pre>
</p>
<p>This might be suitable for a very simple quantum control system
with a single counter for loops.
</p><a name='6-3-6-2Memory-Mapped-RAM'><h4>6.3.6.2. Memory-Mapped RAM</h4></a>
<p>The following is an example of a memory structure that might be
used in a system with a fixed and known memory layout optimized for
running QAOA-like circuits.


<pre class='source-code'>DECLARE memory OCTET[131072]                              # 128k global memory
DECLARE qaoa-params REAL[32] SHARING memory               # all QAOA params
DECLARE beta REAL[16] SHARING qaoa-params                 # beta params
DECLARE gamma REAL[16] SHARING qaoa-params OFFSET 16 REAL # gamma params
DECLARE ro BIT[16]                                        # readout registers</pre>
</p>
<p>Here, we have two disjoint memories: the global data memory
<tt>memory</tt>, and the readout memory <tt>ro</tt>. We see that the global data
memory <tt>memory</tt> is further partitioned into a section
<tt>qaoa-params</tt> specifically for QAOA parameters, which may be useful
if you&#039;re changing them all at once. Nonetheless, for actual use in
Quil code, the actual <tt>beta</tt> and <tt>gamma</tt> parameters are carved out
of this memory.
</p>
<p>This particular scheme may be necessary if software processing Quil
does not have any ability generate memory maps automatically. If that
functionality were possible, one could simply declare <tt>beta</tt>,
<tt>gamma</tt>, and <tt>ro</tt> and let the compilation software take care of
mapping that to physical memory.
</p><a name='6-3-6-3Computing-Bits-of-an-Angle'><h4>6.3.6.3. Computing Bits of an Angle</h4></a>
<p>In algorithms like phase estimation, we compute one bit of the result
at a time with each measurement. If our <tt>INTEGER</tt> data type has the
standard binary representation, then one can do:


<pre class='source-code'>DECLARE unadjusted-theta INTEGER
DECLARE ro BIT[16] SHARING unadjusted-theta
DECLARE theta REAL
# &lt;phase estimation&gt;
MEASURE 0 ro[0]
MEASURE 1 ro[1]
# ...
MEASURE 15 ro[15]</pre>
</p>
<p>Here, we have a 16-bit integer <tt>unadjusted-theta</tt> with the LSB of
our estimated phase starting with qubit 0. (This depends on our
convention in our implementation of phase estimation.) Since
<tt>unadjusted-theta</tt> and <tt>ro</tt> are shared, the bits of <tt>ro</tt>
directly affect the bits of our integer. Recalling that phase
estimation gives us a bitstring (in this case, an integer between
\(0\) and \(2^{16} - 1\)), we must actually adjust it by multiplying by
\(2\pi/2^{16}\), which is approximately \(9.587379924285257\times
10^{-5}\).
</p>
<p>Since <tt>theta</tt> and <tt>unadjusted-theta</tt> have different types, we
can&#039;t quite yet do this multiplication. We need to convert
<tt>unadjusted-theta</tt> into a <tt>REAL</tt> representation on which we can do
fractional arithmetic. We can do this with <tt>CONVERT</tt>, which in other
languages is known as a <em>cast</em> or <em>coercion</em>.


<pre class='source-code'>CONVERT theta unadjusted-theta   # convert INTEGER to REAL
MUL     theta theta 9.587379924285257e-5</pre>
</p>
<p>Now we can use <tt>theta</tt> as an argument to an angle if we
please. For example, we might do a phase adjustment based off of that
angle on qubit <tt>16</tt>:


<pre class='source-code'>RZ(theta) 16</pre>
</p><a name='6-4Memory-Access-and-Dereferencing'><h3>6.4. Memory Access and Dereferencing</h3></a>
<p>Memory is dereferenced in a Quil program using common array
access syntax. In particular, given a name <tt>x</tt> pointing to
memory of type \(T\), and a non-negative integer offset \(n\), the
syntax <tt>x[\(n\)]</tt> refers to the \(n\)th element of type \(T\) indexing
off of <tt>x[0]</tt>.
</p>
<p>If and only if <tt>x</tt> was declared with just a single element, then
<tt>x</tt> may be referred to simply by its name with no bracket. In this
case, <tt>x</tt> and <tt>x[0]</tt> would be equivalent.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Memory Reference</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span>[<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Integer</span><span class='meta-syntax'>&#x27E9;</span>]</code></td></tr></table></div><p class='aside'><b>Note: </b>Note that this memory reference is <em>formal</em>. The lone
<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span> in certain contexts may refer to a named argument of,
for example, a circuit definition.</p>
<p>Dereferencing with indirection, e.g., something akin to
<tt>x[y[3]]</tt>, is supported through the <tt>LOAD</tt> and <tt>STORE</tt>
instructions. For example,


<pre class='source-code'>DECLARE x INTEGER[16]
DECLARE y INTEGER[16]
DECLARE z INTEGER[16]
DECLARE t INTEGER
LOAD t y z[3]          # t := y[z[3]]
LOAD t x t             # t := x[t]</pre>
</p><a name='6-5Classical-Instructions'><h3>6.5. Classical Instructions</h3></a>
<p>With typed memory comes a bag of new instructions. Classical
instructions come in unary (single-argument), binary
(double-argument), and ternary (triple-argument) forms. They all share
the same syntax.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Classical Memory Instruction</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Classical Unary</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Memory Reference</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Classical Binary</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Memory Reference</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>2</sup></span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Classical Ternary</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Memory Reference</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>3</sup></span></code></td></tr></table></div>
<p>The unary instruction names are:
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Classical Unary</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code>NOT </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> NEG</code></td></tr></table></div>
<p>The binary instruction names are:
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Classical Binary</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code>MOVE </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> EXCHANGE </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> CONVERT
    </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> AND </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> IOR </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> XOR
    </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> ADD </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> SUB </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> MUL </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> DIV</code></td></tr></table></div>
<p>The ternary instruction names are:
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Classical Ternary</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code>LOAD </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> STORE </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> EQ </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> GT </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> GE </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> LT </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> LE</code></td></tr></table></div>
<p>While the instructions all take memory references, they only take
memory references of certain type combinations. Each combination is
called an &quot;instruction mode&quot;. In the following table, we use the
following notation to denote an instruction <tt>INSTR</tt> and its modes:


<pre class='source-code'># Category of instruction
INSTR   a b             # Pseudocode meaning
        &lt;type1a&gt; &lt;type1b&gt;
        &lt;type2a&gt; &lt;type2b&gt;
        ...</pre>
</p>
<p>The possibilities for <tt>&lt;typeXY&gt;</tt> are:

<ul><li><tt>&lt;!int&gt;</tt>  : Immediate (literal) integer, also used for octets (<tt>0</tt> to <tt>255</tt>) and bits (<tt>0</tt> and <tt>1</tt>)</li><li><tt>&lt;int&gt;</tt>   : Memory reference to an integer</li><li><tt>&lt;int*&gt;</tt>  : Name of a vector of declared integers</li><li><tt>&lt;!real&gt;</tt> : Immediate (literal) real</li><li><tt>&lt;real&gt;</tt>  : Memory reference to a real</li><li><tt>&lt;real*&gt;</tt> : Name of a vector of declared reals</li><li><tt>&lt;bit&gt;</tt>   : Memory reference to a bit</li><li><tt>&lt;bit*&gt;</tt>  : Name of a vector of declared bits</li><li><tt>&lt;oct&gt;</tt>   : Memory reference to an octet</li><li><tt>&lt;oct*&gt;</tt>  : Name of a vector of declared octets</li></ul>
</p>
<p>Octet literals share the same syntax as integer literals.
</p>
<p>We generally follow the <tt>dest</tt>-<tt>src</tt> ordering of arguments.
</p>
<pre class='source-code'># Move like-typed data to different locations.
# Also allows loading immediate values.
MOVE     a b            # a := b; Store contents of b at a
         &lt;oct&gt; &lt;!int&gt;
         &lt;oct&gt; &lt;oct&gt;
         &lt;int&gt; &lt;!int&gt;
         &lt;int&gt; &lt;int&gt;
         &lt;real&gt; &lt;!real&gt;
         &lt;real&gt; &lt;real&gt;
         &lt;bit&gt; &lt;!int&gt;
         &lt;bit&gt; &lt;bit&gt;

# Exchange the value at two like-typed locations.
EXCHANGE a b            # Exchange contents of a and b; a &lt;=&gt; b
         &lt;oct&gt; &lt;oct&gt;
         &lt;int&gt; &lt;int&gt;
         &lt;real&gt; &lt;real&gt;
         &lt;bit&gt; &lt;bit&gt;

# Perform an indirect load from x offset by n to a.
LOAD     a x n          # a := x[n]
         &lt;oct&gt; &lt;oct*&gt; &lt;int&gt;
         &lt;int&gt; &lt;int*&gt; &lt;int&gt;
         &lt;real&gt; &lt;real*&gt; &lt;int&gt;
         &lt;bit&gt; &lt;bit*&gt; &lt;int&gt;

# Perform an indirect store of a to x offset by n.
STORE    x n a          # x[n] := a
         &lt;oct*&gt; &lt;int&gt; &lt;oct&gt;
         &lt;oct*&gt; &lt;int&gt; &lt;!int&gt;
         &lt;int*&gt; &lt;int&gt; &lt;int&gt;
         &lt;int*&gt; &lt;int&gt; &lt;!int&gt;
         &lt;real*&gt; &lt;int&gt; &lt;real&gt;
         &lt;real*&gt; &lt;int&gt; &lt;!real&gt;
         &lt;bit*&gt; &lt;int&gt; &lt;bit&gt;
         &lt;bit*&gt; &lt;int&gt; &lt;!int&gt;

# Perform a move of differently typed data.
# The data here is interpreted numerically.
CONVERT  a b            # a := (T)b, where T = type-of(a)
         &lt;int&gt; &lt;real&gt;   # - Best integer approximation of a real.
         &lt;int&gt; &lt;bit&gt;    # - Convert 0 or 1 to an integer.
         &lt;real&gt; &lt;int&gt;   # - Best real approximation of an integer.
         &lt;real&gt; &lt;bit&gt;   # - Convert 0 or 1 to a real.
         &lt;bit&gt; &lt;int&gt;    # - 0 if 0, 1 if non-zero.
         &lt;bit&gt; &lt;real&gt;   # - 0 if 0.0, 1 if non-zero

# Logical Operations
NOT      a              # a := ~a
         &lt;oct&gt;
         &lt;int&gt;
         &lt;bit&gt;

AND      a b            # a := a &amp; b
IOR      a b            # a := a | b
XOR      a b            # a := a ^ b
         &lt;oct&gt; &lt;oct&gt;
         &lt;oct&gt; &lt;!int&gt;
         &lt;int&gt; &lt;int&gt;
         &lt;int&gt; &lt;!int&gt;
         &lt;bit&gt; &lt;bit&gt;
         &lt;bit&gt; &lt;!int&gt;

# Arithmetic Operations
NEG      a              # a := -a
         &lt;int&gt;
         &lt;real&gt;

ADD      a b            # a := a + b
SUB      a b            # a := a - b
MUL      a b            # a := a * b
DIV      a b            # a := a / b
         &lt;int&gt; &lt;int&gt;
         &lt;int&gt; &lt;!int&gt;
         &lt;real&gt; &lt;!real&gt;
         &lt;real&gt; &lt;real&gt;

# Comparison
EQ       r a b          # r := (a == b)
GT       r a b          # r := (a &gt; b)
GE       r a b          # r := (a &gt;= b)
LT       r a b          # r := (a &lt; b)
LE       r a b          # r := (a &lt;= b)
         &lt;bit&gt; &lt;bit&gt; &lt;bit&gt;
         &lt;bit&gt; &lt;bit&gt; &lt;!int&gt;
         &lt;bit&gt; &lt;oct&gt; &lt;oct&gt;
         &lt;bit&gt; &lt;oct&gt; &lt;!int&gt;
         &lt;bit&gt; &lt;int&gt; &lt;int&gt;
         &lt;bit&gt; &lt;int&gt; &lt;!int&gt;
         &lt;bit&gt; &lt;real&gt; &lt;real&gt;
         &lt;bit&gt; &lt;real&gt; &lt;!real&gt;</pre><a name='7Measurement'><h2>7. Measurement</h2></a>
<p>Measurement is the only way in which the quantum state can affect
classical memory. Measurement comes in two flavors:
<em>measurement-for-effect</em> and <em>measurement-for-record</em>.
</p>
<p>Measurement-for-effect measures a single qubit and discards the
result.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Measurement for Effect</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>MEASURE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Formal Qubit</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>Measurement will stochastically project the qubit into either the
zero-state or the one-state depending on its probability of such
dictated by the wavefunction amplitudes.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Measurement for Record</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>MEASURE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Formal Qubit</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Memory Reference</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>Here, the memory reference must be either of type <tt>BIT</tt> or
<tt>INTEGER</tt>. In either case, a \(0\) is deposited at the memory
location if the qubit was measured to be in the zero-state, and a
\(1\) otherwise.
</p>
<p>These measurement varieties make up all measurement instructions.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Measurement Instruction</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Measurement for Effect</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Measurement for Record</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div>
<p>Note that there is no way in Quil to measure all qubits
simultaneously.
</p><a name='8Classical-Control'><h2>8. Classical Control</h2></a><a name='8-1Halting-the-Program'><h3>8.1. Halting the Program</h3></a>
<p>The program is <em>halted</em> if it is no longer executing. This may
happen under one of three conditions:

<ul><li>The <tt>HALT</tt> instruction was executed,</li><li>The program counter reaches \(\vert P\vert\), or</li><li>An implementation-dependent error condition has happened.</li></ul>
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Halt Instruction</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>HALT</code></p></div>
<p>Error conditions may happen, for instance, when a division-by-zero
occurs. There may be other ways in which an implementation may error.
</p><a name='8-2Program-Labels-and-Branching'><h3>8.2. Program Labels and Branching</h3></a>
<p>Run-time control flow is achieved through a variety of branching
instructions. Each branching instructions requires a target place in
the program to jump to. These target places are denoted by
<em>labels</em>:
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Jump Target</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>@<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span></code></p></div><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Label</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>LABEL <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Jump Target</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>A label (resp. jump target) is said to be at position \(p < \vert
P\vert\) if the first instruction that follows the label (resp. jump
target&#039;s label) is the \(p\)th instruction (zero-indexed). If no
instruction follows the label, then it is said to be a <em>halting
label at position \(\vert P\vert\)</em>.
</p>
<p>Each <tt>LABEL</tt> jump target name must be unique. It is an error to
have a duplicate jump target name in a program.
</p><p class='aside'><b>Note: </b>Jump target names may be duplicated across (but not within)
<tt>DEFCIRCUIT</tt> bodies if and only if those names don&#039;t appear globally
within the program in which the <tt>DEFCIRCUIT</tt> is expanded. Names may
be duplicated because they are made unique when the circuit is
expanded.</p>
<p>One may transfer control to the \(p\)th position of a program by
using a <tt>JUMP</tt> instruction targeting a label at position \(p\).
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Unconditional Branch Instruction</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>JUMP <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Jump Target</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>One may transfer control to the \(p\)th position of a program
conditional on a given memory reference using one of the following two
instructions:
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Conditional Branch Instruction</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code>JUMP-WHEN <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Jump Target</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Memory Reference</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> JUMP-UNLESS <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Jump Target</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Memory Reference</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div>
<p>The <tt>JUMP-WHEN</tt> (resp. <tt>JUMP-UNLESS</tt>) instruction branches if
and only if <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Memory Reference</span><span class='meta-syntax'>&#x27E9;</span> references a <tt>BIT</tt>-typed value
that is non-zero (resp. exactly zero).
</p>
<p>Together, these form the branching instructions.
</p><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Branch Instruction</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Unconditional Branch Instruction</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Conditional Branch Instruction</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr></table></div><a name='9Other-Instructions-and-Directives'><h2>9. Other Instructions and Directives</h2></a><a name='9-1No-Operation-Instruction'><h3>9.1. No-Operation Instruction</h3></a>
<p>The <em>no-operation instruction</em> or <em><tt>NOP</tt> instruction</em> is an instruction which does not affect the classical or quantum state of the QAM. It only affects the control state by incrementing the program counter by \(1\).
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>No-Operation Instruction</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>NOP</code></p></div><a name='9-2Pragmas'><h3>9.2. Pragmas</h3></a>
<p>Programs that process Quil code may want to take advantage of extra
information provided by the programmer. This is especially true when
targeting quantum processors where additional information about the
machine&#x2019;s characteristics affect how the program will be
processed. Quil supports a <tt>PRAGMA</tt> directive to include extra
information in a program which does not otherwise affect execution
semantics.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Pragma</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>PRAGMA <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'> | </span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Integer</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>)</span><span class='meta-syntax'><sup>*</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>String</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>?</sup></span></code></p></div><a name='9-3File-Inclusion'><h3>9.3. File Inclusion</h3></a>
<p>One can include a valid Quil file in another valid Quil file by
inclusion.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>File Include</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>INCLUDE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>String</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>Here, <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>String</span><span class='meta-syntax'>&#x27E9;</span> denotes a file name. Implementations processing
Quil must support and document individual file names, and may support
operating-system-dependent file paths.
</p><a name='10Circuits'><h2>10. Circuits</h2></a><a name='10-1Circuit-Syntax'><h3>10.1. Circuit Syntax</h3></a>
<p>Circuits in Quil are parameterized templates of instructions that
can be filled in with parameters and arguments. Circuit applications
within a program are expanded according to the circuit&#039;s definition in
full before a Quil program is executed.
</p><p class='aside'><b>Note: </b>Circuits are intended to be used more as macros than as
specifications for general quantum circuits. Indeed, <tt>DEFCIRCUIT</tt> is
very limited in its expressiveness, only performing argument and
parameter substitution. It is included mainly to help with the
debugging and human readability of Quil code. Circuits in Quil are
more like C preprocessor macros than they are like functions. The QAM
has no notion of a circuit as a part of its semantics; circuits are
simply notational conveniences.</p>
<p>A circuit is defined with the <tt>DEFGATE</tt> directive.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Circuit Definition</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>DEFCIRCUIT <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span>(<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameters</span><span class='meta-syntax'>&#x27E9;</span>)<span class='meta-syntax'>)</span><span class='meta-syntax'><sup>?</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Arguments</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>?</sup></span>
:
<span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Indent</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Circuit Instruction</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>*</sup></span></code></p></div>
<p>Within the circuit body, we can write any Quil instruction,
allowing for the named parameters and arguments to show up as
instruction parameters or arguments.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Circuit Instruction</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Instruction</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Terminator</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>A circuit may be used similarly to a gate:
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Circuit Application</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span>(
                <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression List</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>?</sup></span>
            )<span class='meta-syntax'>)</span><span class='meta-syntax'><sup>?</sup></span><span class='meta-syntax'>(</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Formal Qubit</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'> | </span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Memory Reference</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>)</span><span class='meta-syntax'><sup>+</sup></span></code></p></div><a name='10-2Circuit-Expansion'><h3>10.2. Circuit Expansion</h3></a>
<p>Circuits are expanded recursively, outside in. Circuits may not be
self-recursive or mutually recursive. These circuits are invalid
because they exhibit different kinds of non-terminating recursion.
</p>
<pre class='source-code'>DEFCIRCUIT FOO:
    BAR

DEFCIRCUIT BAR:
    FOO

DEFCIRCUIT BAZ:
    BAZ</pre>
<p>Labels that are declared within the body of a <tt>DEFCIRCUIT</tt> are
unique to each of that circuit&#039;s expansions. While it is possible to
jump out of a <tt>DEFCIRCUIT</tt> to a globally declared label, it is not
possible to jump inside of one.
</p>
<p>Consider the following two <tt>DEFCIRCUIT</tt> declarations and their
instantiations. Note the comments on correct and incorrect usages of
<tt>JUMP</tt>.


<pre class='source-code'>DEFCIRCUIT FOO:
    LABEL @FOO_A
    JUMP @GLOBAL   # (A) valid, global label
    JUMP @FOO_A    # (B) valid, local to FOO
    JUMP @BAR_A    # (C) invalid

DEFCIRCUIT BAR:
    LABEL @BAR_A
    JUMP @FOO_A    # (D) invalid

LABEL @GLOBAL
FOO
BAR
JUMP @FOO_A        # (E) invalid
JUMP @BAR_A        # (F) invalid</pre>

Line (A) is valid because it is a jump from a circuit to a global
label called <tt>@GLOBAL</tt>.

Line (B) is valid because it is a jump to a label within the same
circuit body.

Line (C) is invalid because it is erroneously attempting to jump to a
different circuit body.

Line (D) is invalid for the same reason as line (C); it is an
erroneous attempt to jump from one local circuit body to another.

Lines (E) and (F) are both invalid because they are attempts to jump
into a local circuit definition.
</p><a name='11History-and-Changes'><h2>11. History and Changes</h2></a><a name='11-1A-History-of-Quil'><h3>11.1. A History of Quil</h3></a>
<p>In 2016, at Rigetti Computing, Quil was defined in an <a href='https://arxiv.org/abs/1608.03355'>arXiv paper</a> entitled &quot;A Practical
Quantum Instruction Set Architecture&quot; by R. Smith, M. Curtis, and
W. Zeng.
</p>
<p>In 2018, at Rigetti Computing, R. Smith began work to amend Quil to
include a memory model. Its definition lived in a new Git repository
containing the Quil specification.
</p>
<p>In 2019, at Rigetti Computing, Quil&#039;s specification was rewritten
in Markdown format by S. Heidel and other Rigetti-based contributors
for easier consumption. S. Heidel also contributed an ANTLR grammar
for Quil.
</p>
<p>In 2019, at Rigetti Computing, an extension of Quil for
time-domain, pulse-level control was developed by S. Heidel, E. Davis,
and other Rigetti-based contributors. This was code-named &quot;Quilt&quot; but
was later finalized as &quot;Quil-T&quot;. Quil-T lived as a proposed extension
(called an &quot;RFC&quot;) in the Git repository.
</p>
<p>In 2019, at Rigetti Computing, an addition to Quil to allow gates
to be defined as exponentiated Pauli sums was developed by
E. Peterson. This was code-named &quot;defexpi&quot; but was later finalized as
syntax <tt>DEFGATE AS PAULI-SUM</tt>. This syntax lived as an RFC in the
Git repository.
</p>
<p>In 2021, R. Smith (whose affiliation since changed to HRL
Laboratories) and Rigetti Computing set up the <em>Quil-Lang</em> GitHub
organization for shared and collaborative governance of the definition
of Quil as well as its <em>de facto</em> standard software tooling.
</p>
<p>In 2021, R. Smith rewrote the specification in a custom format to
allow rendering as an HTML page. The specification was synthesized
from all previous official sources on the language.
</p>
<p>Quil&#039;s specification, as well as software implementations, have
benefited greatly from their international userbase. Quil has also
benefited from a diverse ecosystem of other quantum computing
languages, such as OpenQASM, Quipper, Q#, and QCL.
</p><a name='11-2Changes'><h3>11.2. Changes</h3></a>
<p><em>This document only tracks changes since its conception.</em>
</p>
<p><ul><li>July 2021: Document created.</li></ul>
</p><a name='12Annex-T--Pulse-Level-Control'><h2>12. Annex T: Pulse-Level Control</h2></a>
<p>This section is about time-domain extensions to Quil, formally known as <em>Annex T</em> of this document, but also known as <em>Quil-T</em>.
</p><a name='12-1Frames'><h3>12.1. Frames</h3></a><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame Identifier</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>String</span><span class='meta-syntax'>&#x27E9;</span></code></p></div><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Qubit</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>+</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame Identifier</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>A frame encapsulates any rotating frame relative to which control/readout
waveforms may be defined. For the purposes of scheduling and execution on
possibly heterogenous hardware, frames are specified with respect to a specific
list of qubits. Thus, <tt>0 1 &quot;cz&quot;</tt> is the &quot;cz&quot; frame on qubits 0 and 1. The order
of the qubits matters. In particular, the above frame may differ from <tt>1 0 &quot;cz&quot;</tt>.
</p><a name='12-1-1DEFFRAME'><h4>12.1.1. DEFFRAME</h4></a>
<p>Quil-T itself has no built-in frames. Frames must be defined using the <tt>DEFFRAME</tt>
directive.
</p><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame Definition</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>DEFFRAME <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>(</span>: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame Specification</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>+</sup></span><span class='meta-syntax'>)</span><span class='meta-syntax'><sup>?</sup></span></code></p></div><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame Specification</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Indent</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame Attribute</span><span class='meta-syntax'>&#x27E9;</span> : <span class='meta-syntax'>(</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'> | </span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>String</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>)</span></code></p></div><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame Attribute</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code>SAMPLE-RATE </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> INITIAL-FREQUENCY </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> DIRECTION </code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> HARDWARE-OBJECT</code></td></tr></table></div>
<p>All frames used in a program must have a corresponding top-level definition.
</p>
<p>Before execution, a Quil-T program is linked with a specific system of control
hardware, and frames are mapped to suitable hardware objects (cf. the
<tt>HARDWARE-OBJECT</tt> frame attribute below). Native or canonical frame definitions may be
provided by a hardware vendor. Some examples of Rigetti&#039;s canonical frames are
listed below, but this is subject to change.
</p>
<p>Examples (names only):


<pre class='source-code'>&quot;xy&quot;  # eg. for the drive line
&quot;ff&quot;  # eg. for a generic flux line
&quot;cz&quot;  # eg. for a flux pulse for enacting CZ gate
&quot;iswap&quot;
&quot;ro&quot;  # eg. for the readout pulse
&quot;out&quot; # eg. for the capture line</pre>
</p><a name='12-1-1-1Frame-Attributes'><h4>12.1.1.1. Frame Attributes</h4></a>
<p>Frame attributes represent quantities associated with a given frame which need not be specified by the programmer, but which are ultimately required to fully link and execute a Quil-T program on a physical device.
</p><ul><li><tt>SAMPLE-RATE</tt> is a floating point number indicating the rate (in Hz) of the digital-to-analog converter on the control hardware associated with this frame.</li><li><tt>INITIAL-FREQUENCY</tt> is a floating point number indicating the initial frame frequency.</li><li><tt>DIRECTION</tt> is one of <tt>&quot;tx&quot;</tt> or <tt>&quot;rx&quot;</tt>.</li><li><tt>HARDWARE-OBJECT</tt> is a string indicating the (implementation-specific) hardware object that the frame is associated with.</li></ul><a name='12-2Waveforms'><h3>12.2. Waveforms</h3></a><div class='syntax'><table border='0' cellpadding='4'><tr><td style='text-align:right'><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Waveform</span><span class='meta-syntax'>&#x27E9;</span> ::=</td><td><code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span></code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> flat ( duration: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span>, iq: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> )
</code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> gaussian ( duration: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span>, fwhm: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span>, t0: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> )
</code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> draggaussian ( duration: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span>, fwhm: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span>, t0: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span>, anh: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span>, alpha: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> )
</code></td></tr><tr><td style='text-align:right'><span class='meta-syntax'>|</span></td><td><code> erfsquare ( duration: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span>, risetime: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span>, padleft: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span>, padright: <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span> )</code></td></tr></table></div>
<p>Waveforms are referenced either by name or by a built-in waveform generator.
</p>
<p>The built-in waveform generators are:
<ul><li><tt>flat(duration, iq)</tt> creates a flat waveform where:
    <ul><li><tt>duration</tt> is a rational number representing the duration of the
      waveform in seconds</li><li><tt>iq</tt> is a complex number representing the IQ value to play for the
      duration of the waveform</li></ul></li><li><tt>gaussian(duration, fwhm, t0)</tt> creates a Gaussian waveform where:
<ul><li><tt>duration</tt> is a rational number representing the duration of the
      waveform in seconds</li><li><tt>fwhm</tt> is a rational number representing the full-width-half-max of
      the waveform in seconds</li><li><tt>t0</tt> is a rational number representing the center time coordinate of
      the waveform in seconds</li></ul></li><li><tt>draggaussian(duration, fwhm, t0, anh, alpha)</tt> creates a DRAG gaussian pulse where:
<ul><li><tt>duration</tt> is a rational number representing the duration of the
      waveform in seconds</li><li><tt>fwhm</tt> is a rational number representing the full-width-half-max of
      the waveform in seconds</li><li><tt>t0</tt> is a rational number representing the center time coordinate of
      the waveform in seconds</li><li><tt>anh</tt> is a rational number representing the anharmonicity of the qubit in
      Hertz</li><li><tt>alpha</tt> is a rational number for the dimensionless drag parameter</li></ul></li><li><tt>erfsquare(duration, risetime, padleft, padright)</tt> creates a pulse with a flat top and edges that are error functions (erfs) where:
<ul><li><tt>duration</tt> is a rational number representing the duration of the
      waveform in seconds</li><li><tt>risetime</tt> is a rational number representing the rise and fall sections of
      the pulse in seconds</li><li><tt>padleft</tt> is a rational number representing the amount of zero-amplitude
      padding to add to the left of the pulse</li><li><tt>padright</tt> is a rational number representing the amount of zero-amplitude
      padding to add to the right of the pulse</li></ul></li></ul>
</p><a name='12-2-1Defining-new-waveforms'><h4>12.2.1. Defining new waveforms</h4></a><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Sample Rate</span><span class='meta-syntax'>&#x27E9;</span> ::= <code><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Real</span><span class='meta-syntax'>&#x27E9;</span></code></p></div><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Waveform Definition</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>DEFWAVEFORM <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span> ( <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameters</span><span class='meta-syntax'>&#x27E9;</span> ) <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Sample Rate</span><span class='meta-syntax'>&#x27E9;</span> : <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Matrix Entries</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>New waveforms may be defined by specifying the sample rate (in
Hertz) and listing out all the IQ values as complex numbers, separated
by commas. Waveform definitions may also be parameterized, although
note that Quil has no support for vector level operations.
</p>
<p>Example:

<pre class='source-code'>DEFWAVEFORM my_custom_waveform 6.0:
    1+2i, 3+4i, 5+6i

DEFWAVEFORM my_custom_parameterized_waveform(%a) 6.0:
    (1+2i)*%a, (3+4i)*%a, (5+6i)*%a</pre>
</p>
<p>The duration (in seconds) of a custom waveform may be computed by dividing the
number of samples by the sample rate. In the above example, both waveforms have
a duration of 0.5 seconds.
</p><a name='12-3Pulses'><h3>12.3. Pulses</h3></a><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Pulse</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>PULSE Frame Waveform</code></p></div>
<p>Pulses represent the propagation of a specific waveform (either built-in or custom) on a specific frame.
</p>
<p>Examples:


<pre class='source-code'># Simple pulse with previously defined waveform
PULSE 0 &quot;xy&quot; my_custom_waveform

# Pulse with previously defined parameterized waveform
PULSE 0 &quot;xy&quot; my_custom_parameterized_waveform(0.5)

# Pulse with built-in waveform generator
PULSE 0 &quot;xy&quot; flat(duration: 1e-6, iq: 2+3i)

# Pulse on a flux line
PULSE 0 1 &quot;cz&quot; flat(duration: 1e-6, iq: 2+3i)</pre>
</p>
<p>Each frame has a fixed, hardware-specific sample rate. The behavior of a <tt>PULSE</tt>
instruction with a custom waveform whose sample rate does not match the
corresponding frame&#039;s sample rate is undefined.
</p><a name='12-4Frame-Mutations'><h3>12.4. Frame Mutations</h3></a><a name='12-4-1Frequency'><h4>12.4.1. Frequency</h4></a><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Set Frequency</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>SET-FREQUENCY <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Real</span><span class='meta-syntax'>&#x27E9;</span></code></p></div><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Shift Frequency</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>SHIFT-FREQUENCY <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Real</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>Each frame has a frequency which is tracked throughout the program. Initial
frame frequencies are specified in the frame definition&#039;s <tt>INITIAL-FREQUENCY</tt>
attribute. Subsequent code may update this, either assigning an absolute value (<tt>SET-FREQUENCY</tt>) or a relative offset (<tt>SHIFT-FREQUENCY</tt>).
</p>
<pre class='source-code'>SET-FREQUENCY 0 &quot;xy&quot; 5.4e9
SHIFT-FREQUENCY 0 &quot;ro&quot; 6.1e9</pre><a name='12-4-2Phase'><h4>12.4.2. Phase</h4></a><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Set Phase</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>SET-PHASE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Real</span><span class='meta-syntax'>&#x27E9;</span></code></p></div><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Shift Phase</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>SHIFT-PHASE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span></code></p></div><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Swap Phases</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>SWAP-PHASES <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>Each frame has a phase which is tracked throughout the program. Initially the
phase starts out as 0. It may be set or shifted up and down, as well as swapped
with other frames.
</p>
<p>The phase must be a rational real number. There is also support for
shifted the phase based on some expression, as long as that expression returns
a real number.
</p>
<p>Example:


<pre class='source-code'>SET-PHASE 0 &quot;xy&quot; pi/2

SHIFT-PHASE 0 &quot;xy&quot; -pi
SHIFT-PHASE 0 &quot;xy&quot; %theta*2/pi

SWAP-PHASE 0 &quot;xy&quot; 1 &quot;xy&quot;</pre>
</p><a name='12-4-3Scale'><h4>12.4.3. Scale</h4></a><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Set Scale</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>SET-SCALE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Real</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>Each frame has a scale which is tracked throughout the program. The
scale is initially 1.
</p>
<p>Example:


<pre class='source-code'>SET-SCALE 0 &quot;xy&quot; 0.75</pre>
</p><a name='12-5Capture'><h3>12.5. Capture</h3></a><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Capture</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>CAPTURE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Waveform</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Memory Reference</span><span class='meta-syntax'>&#x27E9;</span></code></p></div><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Raw Capture</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>RAW-CAPTURE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Memory Reference</span><span class='meta-syntax'>&#x27E9;</span></code></p></div>
<p>The capture instruction opens up the readout on a frame and measures its state.
An integration waveform will be applied to the raw IQ points and the result is
placed in classical memory.
</p>
<p>The waveform will define the duration of the capture. The memory reference must
be able to store a complex number for each qubit in the frame.
</p>
<p>In the case of a raw capture the waveform is replaced with a rational number
representing the duration of the capture.
</p>
<p>Example:


<pre class='source-code'># Simple capture of an IQ point
DECLARE iq REAL[2]
CAPTURE 0 &quot;out&quot; flat(1e-6, 2+3i) iq

# Raw capture
DECLARE iqs REAL[400] # length needs to be determined based on the sample rate
CAPTURE 0 &quot;out&quot; 200e-6 iqs</pre>
</p>
<p>The behavior of a <tt>CAPTURE</tt> instruction with a custom waveform whose sample rate
does not match the corresponding frame&#039;s sample rate is undefined.
</p><a name='12-6Defining-Calibrations'><h3>12.6. Defining Calibrations</h3></a><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Calibration Definition</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>DEFCAL <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Modifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>*</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span> ( <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameters</span><span class='meta-syntax'>&#x27E9;</span> ) <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Qubit</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>+</sup></span> : <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Instruction</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>+</sup></span></code></p></div><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Measure Calibration</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>DEFCAL <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Identifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Qubit</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>?</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Parameter</span><span class='meta-syntax'>&#x27E9;</span> : <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Instruction</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>+</sup></span></code></p></div>
<p>Calibrations for high-level gates can be defined by mapping a combination of
(gate name, parameters, qubits) to a sequence of analog control instructions.
</p>
<p>Calibrations with the same gate name as a built-in gate definition or custom
gate definition are assumed to be the same.
</p>
<p>Multiple calibration definitions can be defined for different parameter and
qubit values. When a gate is translated into control instructions the
calibration definitions are enumerated in reverse order of definition and the
first match will be taken.
</p>
<p>For example, given the following list of calibration definitions in this order:

<ol><li><tt>DEFCAL RX(%theta) %qubit:</tt></li><li><tt>DEFCAL RX(%theta) 0:</tt></li><li><tt>DEFCAL RX(pi/2) 0:</tt></li></ol>

The instruction <tt>RX(pi/2) 0</tt> would match (3), the instruction <tt>RX(pi) 0</tt> would
match (2), and the instruction <tt>RX(pi/2) 1</tt> would match (1).
</p>
<p>The same system applies for <tt>MEASURE</tt>. Although <tt>MEASURE</tt> cannot be
parameterized, it takes only a single qubit as input, and it has an additional
(optional) parameter for the memory reference into which to store the result.
</p>
<p>Examples:


<pre class='source-code'># Simple non-parameterized gate on qubit 0
DEFCAL X 0:
    PULSE 0 &quot;xy&quot; gaussian(duration: 1, fwhm: 2, t0: 3)

# Parameterized gate on qubit 0
DEFCAL RX(%theta) 0:
    PULSE 0 &quot;xy&quot; flat(duration: 1e-6, iq: 2+3i)*%theta/(2*pi)

# Applying RZ to any qubit
DEFCAL RZ(%theta) %qubit:
    SHIFT-PHASE %qubit &quot;xy&quot; %theta

# Measurement and classification
DEFCAL MEASURE 0 %dest:
    DECLARE iq REAL[2]
    CAPTURE 0 &quot;out&quot; flat(1e-6, 2+3i) iq
    LT %dest iq[0] 0.5 # thresholding</pre>
</p>
<p>Quil supports arbitrarily chained gate modifiers. As such, calibration
definitions may also incorporate gate modifiers, with the convention that a
calibration definition matches a gate application only if the modifiers match
exactly. Thus in


<pre class='source-code'>DEFCAL T 0:
    # ...

DEFCAL DAGGER T 0:
    # ...</pre>

the first calibration definition matches <tt>T 0</tt>, the second matches <tt>DAGGER T 0</tt>,
and neither match <tt>DAGGER DAGGER T 0</tt>.
</p><a name='12-7Timing-and-Synchronization'><h3>12.7. Timing and Synchronization</h3></a><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Delay</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>DELAY <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Qubit</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>+</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Frame Identifier</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>*</sup></span><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Expression</span><span class='meta-syntax'>&#x27E9;</span></code></p></div><div class='syntax'><p><span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Fence</span><span class='meta-syntax'>&#x27E9;</span> ::= <code>FENCE <span class='meta-syntax'>&#x27E8;</span><span class='meta-syntax-identifier'>Qubit</span><span class='meta-syntax'>&#x27E9;</span><span class='meta-syntax'><sup>*</sup></span></code></p></div>
<p>Delay allows for the insertion of a gap within a list of pulses or gates with
a specified duration in seconds.
</p>
<p>If frame names are specified, then the delay instruction affects those frames on
those qubits. If no frame names are specified, all frames on precisely those
qubits are affected.
</p><p class='aside'><b>Note: </b>Note: this excludes frames which <em>intersect</em> the
specified qubits but involve others. For example, <tt>DELAY 0 1.0</tt> delays one qubit
frames on <tt>0</tt>, such as <tt>0 &quot;xy&quot;</tt>, but leaves other frames, such as <tt>0 1 &quot;cz&quot;</tt>,
unaffected.</p>
<p>Fence ensures that all operations involving the specified qubits that follow the
fence statement happen after all operations involving the specified qubits that
preceed the fence statement. If no qubits are specified, the <tt>FENCE</tt> operation
implicitly applies to all qubits on the device.
</p>
<p>Examples:


<pre class='source-code'>X 0
FENCE 0 1
X 1 # This X gate will be applied to qubit 1 AFTER the X gate on qubit 0

# Simple T1 experiment
X 0
DELAY 0 100e-6
MEASURE 0 ro[0]</pre>
</p>
  </body>
</html>